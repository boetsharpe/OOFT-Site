<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <script>
        // Apply cover and hide website immediately on page load
        (function() {
            // Detect if this is a reload
            const isReload = performance.getEntriesByType('navigation')[0]?.type === 'reload' || 
                            (performance.navigation && performance.navigation.type === 1);
            
            const hasHash = window.location.hash && window.location.hash.length > 1;
            if (!hasHash) {
                document.documentElement.classList.add('brand-logo-visible');
                // Disable scrolling when cover is visible
                document.documentElement.style.overflow = 'hidden';
                
                // Prevent scroll events immediately
                function preventScrollEarly(e) {
                    if (document.body && document.body.classList.contains('brand-logo-visible') && 
                        !document.body.classList.contains('website-loaded')) {
                        e.preventDefault();
                        e.stopPropagation();
                        return false;
                    }
                }
                window.addEventListener('scroll', preventScrollEarly, { passive: false, capture: true });
                window.addEventListener('wheel', preventScrollEarly, { passive: false, capture: true });
                window.addEventListener('touchmove', preventScrollEarly, { passive: false, capture: true });
                
                // Apply to body as soon as it exists
                if (document.body) {
                    document.body.classList.add('brand-logo-visible');
                    document.body.style.overflow = 'hidden';
                    // On reload, show website instantly; on first load, wait 1 second
                    if (isReload) {
                        document.body.classList.add('website-loaded');
                        document.body.setAttribute('data-is-reload', 'true');
                    }
                } else {
                    document.addEventListener('DOMContentLoaded', function() {
                        document.body.classList.add('brand-logo-visible');
                        document.body.style.overflow = 'hidden';
                        if (isReload) {
                            document.body.classList.add('website-loaded');
                            document.body.setAttribute('data-is-reload', 'true');
                        }
                    });
                }
            } else {
                // If hash exists, show website immediately
                if (document.body) {
                    document.body.classList.add('website-loaded');
                } else {
                    document.addEventListener('DOMContentLoaded', function() {
                        document.body.classList.add('website-loaded');
                    });
                }
            }
        })();
    </script>

</head>
<body>
    <!-- Top Header Bar -->
    <!-- Static full-width brand SVG overlay -->
    <div class="brand-svgs-static" id="brandSvgsStatic">
        <div class="brand-svg-wrapper-static">
            <img src="SVG/ooft/1.svg" alt="" class="brand-svg-static" />
        </div>
        <div class="brand-svg-wrapper-static">
            <img src="SVG/ooft/2.svg" alt="" class="brand-svg-static" />
        </div>
        <div class="brand-svg-wrapper-static">
            <img src="SVG/ooft/3.svg" alt="" class="brand-svg-static" />
        </div>
        <div class="brand-svg-wrapper-static">
            <img src="SVG/ooft/4.svg" alt="" class="brand-svg-static" />
        </div>
    </div>

    <header class="header-bar header-bar--top" id="headerBarTop">
        <div class="header-bar__left-actions">
            <div class="brand-svgs" id="brandSvgs">
                <div class="brand-svg-wrapper">
                    <img src="SVG/ooft/1.svg" alt="" class="brand-svg" />
                </div>
                <div class="brand-svg-wrapper">
                    <img src="SVG/ooft/2.svg" alt="" class="brand-svg" />
                </div>
                <div class="brand-svg-wrapper">
                    <img src="SVG/ooft/3.svg" alt="" class="brand-svg" />
                </div>
                <div class="brand-svg-wrapper">
                    <img src="SVG/ooft/4.svg" alt="" class="brand-svg" />
                </div>
            </div>
        </div>
        
        <!-- Full Screen Info Overlay -->
        <div class="info-overlay" id="infoOverlay">
            <div class="info-overlay__content">
                <div class="info-overlay__section">
                    <h2>About</h2>
                    <p>Not really a studio. No business plan. Just a place to channel my imagination, mix of skills and interests, and make as much as I can. For myself, and as a creative plugin for agencies and clients. Ideas. Advertising. CGI. Graphic design. Art. Digital things. Physical things. All the things.</p>
                </div>
                
                <div class="info-overlay__section">
                    <h2>Core Services</h2>
                    <ul>
                        <li>3D modelling & rendering</li>
                        <li>Brand creation</li>
                        <li>Brand design systems</li>
                        <li>Creative direction</li>
                        <li>Editing and directing</li>
                        <li>Integrated advertising</li>
                        <li>Motion design</li>
                        <li>Pitch machine</li>
                        <li>Product and packaging</li>
                        <li>Spatial and experiential design</li>
                        <li>Web development</li>
                        <li>World building</li>
                        <li>Cool shit</li>
                    </ul>
                </div>
                
                <div class="info-overlay__section">
                    <h2>Selected Awards</h2>
                    <ul>
                        <li>Cannes Gold Lion × 1</li>
                        <li>Cannes Silver Lion × 4</li>
                        <li>Cannes Bronze Lion × 1</li>
                        <li>D&AD Yellow Pencil × 3</li>
                        <li>D&AD Graphite Pencil × 4</li>
                        <li>D&AD Wood Pencil × 7</li>
                        <li>Beazley Product Design of the Year</li>
                    </ul>
                </div>
                
                <div class="info-overlay__section">
                    <h2>Contact</h2>
                    <p><a href="mailto:les@ooft.studio?subject=Heyyyyyy">les@ooft.studio</a></p>
                    <p><a href="https://www.linkedin.com/in/leslie-sharpe/" target="_blank" rel="noopener noreferrer">LinkedIn</a><br><a href="https://www.instagram.com/ooft.studio/" target="_blank" rel="noopener noreferrer">Instagram</a></p>
                    <p><a href="https://www.are.na/ooft-studio/channels" target="_blank" rel="noopener noreferrer">Are.na</a></p>
                </div>
            </div>
        </div>
        <div class="header-bar__search">
            <div class="search-bar" id="searchBar">
                <img src="SVG/search.svg" alt="Search" class="search-bar__icon" />
                <div class="search-bar__input-container">
                    <div class="search-bar__input-wrapper">
                        <span class="search-bar__prefix">Search </span>
                        <span class="search-bar__animated-text" id="animatedSearchText"><span>leslie.work</span></span>
                    </div>
                    <div class="search-bar__input-wrapper-autocomplete">
                        <input 
                            type="text" 
                            class="search-bar__input" 
                            id="searchInput"
                            placeholder=""
                            autocomplete="off"
                            aria-label="Search"
                        />
                        <span class="search-bar__autocomplete" id="searchAutocomplete"></span>
                    </div>
                </div>
                <img src="SVG/X.svg" alt="Close" class="search-bar__close" id="searchClose" />
            </div>
        </div>
        <div class="header-bar__actions" id="headerActions">
            <button class="btn btn--dark-mode" id="darkModeToggle" aria-label="Toggle dark mode">
                <img src="SVG/Dark.svg" alt="Dark mode" class="btn__icon btn__icon--sun" />
                <img src="SVG/Light.svg" alt="Light mode" class="btn__icon btn__icon--circle" />
            </button>
            <button class="btn" id="zoomOutBtn" aria-label="Zoom out">
                <img src="SVG/-.svg" alt="Zoom out" class="btn__icon btn__icon--zoom-out" />
                <img src="SVG/prev.svg" alt="Previous" class="btn__icon btn__icon--prev" />
            </button>
            <button class="btn" id="zoomInBtn" aria-label="Zoom in">
                <img src="SVG/+.svg" alt="Zoom in" class="btn__icon btn__icon--zoom-in" />
                <img src="SVG/next.svg" alt="Next" class="btn__icon btn__icon--next" />
            </button>
        </div>
    </header>

    <!-- Thumbnail Filmstrip Navigator -->
    <div class="thumbnail-filmstrip" id="thumbnailFilmstrip">
        <div class="filmstrip-container" id="filmstripContainer">
            <!-- Dynamically populated with thumbnails -->
        </div>
    </div>

    <!-- Size Slider -->
    <div class="size-slider">
        <h3>Grid Size</h3>
        <input type="range" min="10" max="18" value="18" class="slider" id="sizeSlider">
        <div class="size-info">
            <span id="columnCount">18</span> columns
        </div>
    </div>

    <!-- Grid Overlay System - Fixed 16 Column Guide -->
    <div class="grid-overlay hidden" id="grid-overlay">
        <div class="grid-column-counter" id="gridColumnCounter">18</div>
        <!-- Fixed 16 Column guides -->
        <div class="column-guide"></div>
        <div class="column-guide"></div>
        <div class="column-guide"></div>
        <div class="column-guide"></div>
        <div class="column-guide"></div>
        <div class="column-guide"></div>
        <div class="column-guide"></div>
        <div class="column-guide"></div>
        <div class="column-guide"></div>
        <div class="column-guide"></div>
        <div class="column-guide"></div>
        <div class="column-guide"></div>
        <div class="column-guide"></div>
        <div class="column-guide"></div>
        <div class="column-guide"></div>
        <div class="column-guide"></div>
    </div>

    <div class="header" style="display: none;">
        <div class="title">Work Portfolio</div>
        <div class="stats" id="stats">Loading...</div>
    </div>

    <div class="page-wrapper">
        <div class="grid-wrapper">
            <div class="grid-section" id="grid">
            </div>
        </div>
    </div>

    <div class="lightbox" id="lightbox">
        <div class="lightbox-content">
            <div id="lightbox-media"></div>
            
            <!-- Apple System UI Video Player Overlay -->
            <div class="video-player-ui" id="video-player-ui">
                <!-- Corner Controls -->
                <button class="corner-control play-pause-corner" id="playPauseBtn">⏸</button>
                <button class="corner-control mute-corner" id="muteBtn">
                    <span class="material-icons mute-icon">volume_up</span>
                </button>
                
                <!-- Progress bar is created dynamically inside lightbox-media -->
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // S3 CONFIGURATION
        // ============================================
        const S3_CONFIG = {
            bucketName: 'leslie-archive',
            region: 'ap-southeast-2',
            cloudFrontUrl: '', // Optional: CloudFront URL
            folderPrefix: '' // Optional: if files are in a subfolder
        };
        
        // Helper function to build S3 URLs
        function getS3Url(path) {
            const basePath = S3_CONFIG.folderPrefix ? 
                `${S3_CONFIG.folderPrefix}${path}` : path;
            
            if (S3_CONFIG.cloudFrontUrl) {
                return `${S3_CONFIG.cloudFrontUrl}/${basePath}`;
            } else {
                return `https://${S3_CONFIG.bucketName}.s3.${S3_CONFIG.region}.amazonaws.com/${basePath}`;
            }
        }
        


        let portfolioData = [];
        let currentIndex = 0;

        // Load portfolio from JSON
        async function loadPortfolio() {
            try {
                document.getElementById('grid').innerHTML = '';
                
                // Load JSON file
                const jsonUrl = './data.json';
                const response = await fetch(jsonUrl);
                if (!response.ok) {
                    throw new Error(`Failed to load JSON: ${response.status}`);
                }
                
                portfolioData = await response.json();
                
                // Sort by date (newest to oldest), then by folder/project name, then by filename order
                portfolioData.sort((a, b) => {
                    const dateA = new Date(a.date || a.modified || '1970-01-01');
                    const dateB = new Date(b.date || b.modified || '1970-01-01');
                    if (dateA.getTime() !== dateB.getTime()) {
                        return dateB - dateA; // Reverse: newest first
                    }
                    // If same date, sort by folder name to keep projects together
                    if (a.folder !== b.folder) {
                        return a.folder.localeCompare(b.folder);
                    }
                    // If same folder, sort by filename order (extract number suffix) - lowest to highest
                    const orderA = a.order || extractOrderNumber(a.filename);
                    const orderB = b.order || extractOrderNumber(b.filename);
                    return orderA - orderB; // Ascending: _01, _02, _03, etc.
                });
                
                console.log(`Loaded ${portfolioData.length} items from JSON`);
                
                // Update search terms from JSON tags
                updateSearchTermsFromCSV();
                
                initGallery();
                return Promise.resolve(); // Return promise for chaining
            } catch (error) {
                console.error('Error loading portfolio:', error);
                document.getElementById('grid').innerHTML = 
                    `<div class="loading">Error loading portfolio: ${error.message}<br>
                    <small>Make sure data.json is in the same directory</small></div>`;
                return Promise.reject(error);
            }
        }
        
        // Load portfolio placeholders immediately on page load
        async function loadPortfolioPlaceholders() {
            try {
                const gallery = document.getElementById('grid');
                if (!gallery) {
                    console.error('Gallery element not found');
                    return;
                }
                gallery.innerHTML = '';
                
                const jsonUrl = './data.json';
                const response = await fetch(jsonUrl);
                if (!response.ok) {
                    throw new Error(`Failed to load JSON: ${response.status}`);
                }
                
                portfolioData = await response.json();
                
                // Sort by date (newest to oldest), then by folder/project name, then by filename order
                portfolioData.sort((a, b) => {
                    const dateA = new Date(a.date || a.modified || '1970-01-01');
                    const dateB = new Date(b.date || b.modified || '1970-01-01');
                    if (dateA.getTime() !== dateB.getTime()) {
                        return dateB - dateA; // Newest first
                    }
                    // If same date, sort by folder name to keep projects together
                    if (a.folder !== b.folder) {
                        return a.folder.localeCompare(b.folder);
                    }
                    // If same folder, sort by filename order number
                    const orderA = a.order || extractOrderNumber(a.filename);
                    const orderB = b.order || extractOrderNumber(b.filename);
                    return orderA - orderB;
                });
                
                console.log(`Loaded ${portfolioData.length} items from JSON`);
                console.log('First item dominantColor:', portfolioData[0]?.dominantColor);
                
                // Update search terms from JSON tags
                updateSearchTermsFromCSV();
                
                // Use the same renderGallery function that works in the other version
                renderGallery(true); // true = initial load
                
                // Check URL hash and open lightbox if present
                checkURLHash();
                
                // Verify placeholders were created
                setTimeout(() => {
                    const placeholders = document.querySelectorAll('.thumbnail-placeholder');
                    console.log(`Placeholders found in DOM: ${placeholders.length}`);
                    if (placeholders.length > 0) {
                        const firstPlaceholder = placeholders[0];
                        const computedStyle = window.getComputedStyle(firstPlaceholder);
                        console.log('First placeholder backgroundColor:', computedStyle.backgroundColor);
                        console.log('First placeholder width:', computedStyle.width);
                        console.log('First placeholder height:', computedStyle.height);
                        console.log('First placeholder inline style:', firstPlaceholder.getAttribute('style'));
                        console.log('First item data:', portfolioData[0]);
                    }
                }, 100);
                
            } catch (error) {
                console.error('Error loading portfolio:', error);
                document.getElementById('grid').innerHTML = 
                    `<div class="error-message">Error loading portfolio: ${error.message}<br>
                    <small>Make sure data.json is in the same directory</small></div>`;
            }
        }
        
        // Enable lazy loading after search transition
        window.loadPortfolioWithAnimation = async function(callback) {
            // Portfolio data and placeholders are already loaded, just enable lazy loading
            if (portfolioData && portfolioData.length > 0) {
                setupLazyLoading();
                if (callback) {
                    callback();
                }
            } else {
                // Fallback: if placeholders weren't loaded, load everything now
                await loadPortfolioPlaceholders();
                setupLazyLoading();
                if (callback) {
                    callback();
                }
            }
        };
        
        // Extract date from folder name (e.g., "2016-01_TigerBeer_UNCAGE_01" -> Date)
        function extractDateFromFolder(folder) {
            // Try to match full date with day: YYYY-MM-DD or YYYY_MM_DD
            const fullMatch = folder.match(/^(\d{4})[-_](\d{2})[-_](\d{2})/);
            if (fullMatch) {
                const year = parseInt(fullMatch[1]);
                const month = parseInt(fullMatch[2]) - 1; // JS months are 0-indexed
                const day = parseInt(fullMatch[3]);
                return new Date(year, month, day);
            }
            // Fallback to year-month only: YYYY-MM or YYYY_MM
            const match = folder.match(/^(\d{4})[-_](\d{2})/);
            if (match) {
                const year = parseInt(match[1]);
                const month = parseInt(match[2]) - 1; // JS months are 0-indexed
                return new Date(year, month, 1); // Default to day 1
            }
            return null;
        }
        
        // Extract project name from folder (remove date prefix)
        function extractProjectName(folder) {
            return folder.replace(/^\d{4}-\d{2}_/, '');
        }
        
        // Extract tags from folder name (split by underscores, remove date/number parts)
        function extractTagsFromFolder(folder) {
            const parts = folder.split('_');
            // Remove date prefix and trailing numbers
            const tags = parts.filter((part, index) => {
                if (index === 0 && /^\d{4}-\d{2}$/.test(part)) return false; // Skip date
                if (index === parts.length - 1 && /^\d+$/.test(part)) return false; // Skip trailing number
                return part.length > 0;
            });
            return tags;
        }
        
        // Extract order number from filename (e.g., "file_01.mp4" -> 1)
        function extractOrderNumber(filename) {
            const match = filename.match(/_(\d+)\./);
            return match ? parseInt(match[1]) : 0;
        }
        
        // Build portfolio data from portfolio.json
        function buildPortfolioFromJson(portfolioJson) {
            const items = [];
            
            portfolioJson.projects.forEach(project => {
                const projectDate = project.date || '1970-01-01';
                const projectTags = project.tags || [];
                
                if (project.files && project.files.length > 0) {
                    project.files.forEach(file => {
                        items.push({
                            filename: file.filename,
                            folder: project.folder || project.name,
                            path: `${project.folder || project.name}/${file.filename}`,
                            type: file.type || 'image',
                            metadata: file.metadata || '',
                            dominantColor: file.dominantColor || '#f5f5f5',
                            width: file.width || '',
                            height: file.height || '',
                            date: file.date || projectDate,
                            order: file.order || 0,
                            tags: [...projectTags, ...(file.tags || [])],
                            projectName: project.name
                        });
                    });
                } else {
                    // If no files listed, we'll discover them from S3
                    items.push({
                        folder: project.folder || project.name,
                        projectName: project.name,
                        projectDate: projectDate,
                        projectTags: projectTags,
                        isProjectPlaceholder: true
                    });
                }
            });
            
            return items;
        }
        
        // Scan S3 bucket for projects with project.json files
        async function scanS3ForProjects() {
            const allFiles = await listS3Objects();
            const items = [];
            const projects = new Map();
            
            // Find all project.json files
            const projectJsonFiles = allFiles.filter(f => 
                f.startsWith('work/') && f.endsWith('project.json')
            );
            
            // Load project metadata
            for (const jsonPath of projectJsonFiles) {
                try {
                    const projectUrl = getS3Url(jsonPath);
                    const response = await fetch(projectUrl);
                    if (response.ok) {
                        const projectData = await response.json();
                        const projectFolder = jsonPath.replace('work/', '').replace('/project.json', '');
                        projects.set(projectFolder, projectData);
                    }
                } catch (e) {
                    console.warn(`Failed to load ${jsonPath}:`, e);
                }
            }
            
            // Process work files
            const workFiles = allFiles.filter(f => 
                f.startsWith('work/') && 
                !f.endsWith('/') && 
                !f.endsWith('project.json') &&
                !f.endsWith('.json')
            );
            
            workFiles.forEach(workPath => {
                const relativePath = workPath.replace(/^work\//, '');
                const folder = relativePath.includes('/') ? relativePath.split('/')[0] : '';
                const filename = relativePath.split('/').pop();
                
                const ext = filename.toLowerCase().split('.').pop();
                const isVideo = ['mp4', 'mov', 'webm', 'avi', 'mkv'].includes(ext);
                const isImage = ['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(ext);
                
                if (!isVideo && !isImage) return;
                
                const project = projects.get(folder) || {};
                const projectDate = project.date || '1970-01-01';
                const projectTags = project.tags || [];
                
                // Find file-specific metadata
                const fileData = project.files?.find(f => f.filename === filename) || {};
                
                items.push({
                    filename: filename,
                    folder: folder,
                    path: relativePath,
                    type: isVideo ? 'video' : 'image',
                    metadata: fileData.metadata || '',
                    dominantColor: fileData.dominantColor || '#f5f5f5',
                    width: fileData.width || '',
                    height: fileData.height || '',
                    date: fileData.date || projectDate,
                    order: fileData.order || 0,
                    tags: [...projectTags, ...(fileData.tags || [])],
                    projectName: project.name || folder
                });
            });
            
            // Sort by project date, then file order
            items.sort((a, b) => {
                const dateA = new Date(a.date);
                const dateB = new Date(b.date);
                if (dateA.getTime() !== dateB.getTime()) {
                    return dateA - dateB;
                }
                return (a.order || 0) - (b.order || 0);
            });
            
            return items;
        }
        
        // List all objects in S3 bucket
        async function listS3Objects(prefix = '', continuationToken = null) {
            const allObjects = [];
            let hasMore = true;
            
            while (hasMore) {
                let url = `https://${S3_CONFIG.bucketName}.s3.${S3_CONFIG.region}.amazonaws.com/?list-type=2`;
                if (prefix) {
                    url += `&prefix=${encodeURIComponent(prefix)}`;
                }
                if (continuationToken) {
                    url += `&continuation-token=${encodeURIComponent(continuationToken)}`;
                }
                
                try {
                    const response = await fetch(url, {
                        method: 'GET',
                        mode: 'cors'
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Failed to list bucket: ${response.status}`);
                    }
                    
                    const xmlText = await response.text();
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                    
                    const keys = xmlDoc.getElementsByTagName('Key');
                    for (let i = 0; i < keys.length; i++) {
                        allObjects.push(keys[i].textContent);
                    }
                    
                    const nextToken = xmlDoc.getElementsByTagName('NextContinuationToken');
                    if (nextToken.length > 0) {
                        continuationToken = nextToken[0].textContent;
                    } else {
                        hasMore = false;
                    }
                } catch (error) {
                    console.error('Error listing S3 objects:', error);
                    throw error;
                }
            }
            
            return allObjects;
        }

// Debug function
        function debugColors() {
            console.log('First 5 items with colors:');
            portfolioData.slice(0, 5).forEach(item => {
                console.log(`${item.filename}: ${item.dominantColor || 'MISSING'}`);
            });
        }

        // Calculate aspect ratio for CSS aspect-ratio property
        // Width is always 100% of column, height adjusts to preserve ratio
        function calculateAspectRatio(sourceWidth, sourceHeight) {
            if (!sourceWidth || !sourceHeight || sourceWidth === 0 || sourceHeight === 0) {
                return '1 / 1'; // Fallback to square if dimensions invalid
            }
            
            // Return as CSS aspect-ratio value (width / height)
            return `${sourceWidth} / ${sourceHeight}`;
        }

        // Get current container size based on CSS variables
        function getContainerSize() {
            // Use the CSS variable directly to ensure perfect alignment with grid
            const columnWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--column-width'));
            // Fallback if CSS variable not available yet
            if (isNaN(columnWidth) || columnWidth === 0) {
                // Calculate from available width and grid columns
                const availableWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--available-width')) || 1200;
                const gridColumns = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--grid-columns')) || 10;
                const gridGap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--grid-gap')) || 10;
                const calculatedWidth = (availableWidth - (gridGap * (gridColumns - 1))) / gridColumns;
                return calculatedWidth || 100; // Final fallback
            }
            return columnWidth;
        }

        function initGallery() {
            updateStats();
            debugColors();
            renderGallery(true); // true = initial load
            setupKeyboardNav();
            // Check URL hash and open lightbox if present
            checkURLHash();
        }

        // Track which thumbnail paths have been loaded (for preserving state on zoom)
        const loadedThumbnails = new Set();
        
        function renderGallery(isInitialLoad = false) {
            const gallery = document.getElementById('grid');
            
            // If not initial load, preserve loaded thumbnail paths from current DOM
            if (!isInitialLoad) {
                const existingItems = gallery.querySelectorAll('.item');
                existingItems.forEach(itemEl => {
                    const img = itemEl.querySelector('img.loaded[src]');
                    const video = itemEl.querySelector('video.loaded[src]');
                    if (img || video) {
                        // Get the item index from onclick handler or data attributes
                        const onclickAttr = itemEl.getAttribute('onclick');
                        if (onclickAttr) {
                            const match = onclickAttr.match(/openLightbox\((\d+)\)/);
                            if (match) {
                                const itemIndex = parseInt(match[1]);
                                if (portfolioData[itemIndex] && portfolioData[itemIndex].path) {
                                    loadedThumbnails.add(portfolioData[itemIndex].path);
                                }
                            }
                        }
                    }
                });
            }
            
            gallery.innerHTML = portfolioData.map((item, index) => {
                // Calculate aspect ratio for CSS aspect-ratio property
                // Width will always be 100% of column, height adjusts to preserve ratio
                const aspectRatio = calculateAspectRatio(
                    parseInt(item.width), 
                    parseInt(item.height)
                );
                if (index === 0) {
                    console.log('First item aspect ratio calc:', {
                        width: item.width,
                        height: item.height,
                        aspectRatio: aspectRatio
                    });
                }
                
                // Use thumbnailUrl from JSON, fallback to building URL if not available
                // Special items use their local path directly
                let thumbUrl = item.isSpecial ? item.thumbnailUrl || item.url : item.thumbnailUrl;
                if (!thumbUrl && item.path && !item.isSpecial) {
                    // Ensure path has a valid filename (not just a folder)
                    const pathParts = item.path.split('/');
                    const lastPart = pathParts[pathParts.length - 1];
                    
                    // Skip if path ends with just a folder or has no filename
                    if (lastPart && lastPart !== '' && !lastPart.endsWith('/')) {
                        if (item.type === 'video') {
                            thumbUrl = getS3Url(`thumbnails/${item.path}`);
                        } else {
                            // For images, replace extension with .jpg if it has an extension
                            if (lastPart.includes('.')) {
                                thumbUrl = getS3Url(`thumbnails/${item.path.replace(/\.[^.]+$/, '.jpg')}`);
                            } else {
                                // No extension, append .jpg
                                thumbUrl = getS3Url(`thumbnails/${item.path}.jpg`);
                            }
                        }
                    }
                }
                
                // Check if this thumbnail was already loaded (not initial load)
                const wasLoaded = !isInitialLoad && item.path && loadedThumbnails.has(item.path);
                // Always use data-src for lazy loading on initial load, even if wasLoaded
                const srcAttr = wasLoaded && !isInitialLoad ? `src="${thumbUrl}"` : `data-src="${thumbUrl}"`;
                const loadedClass = wasLoaded ? ' loaded' : '';
                const loadedStyle = wasLoaded ? ' style="opacity: 1;"' : '';
                // Add width/height for better layout stability and performance
                const widthAttr = item.width ? `width="${item.width}"` : '';
                const heightAttr = item.height ? `height="${item.height}"` : '';
                
                return `
                <div class="item" data-type="${item.type}" data-folder="${item.folder}" data-tags="${(item.tags || []).join(',')}" onclick="openLightbox(${index})">
                    <div class="thumbnail" style="aspect-ratio: ${aspectRatio};">
                        <div class="thumbnail-placeholder" style="background-color: ${item.dominantColor || '#f5f5f5'};${wasLoaded ? ' display: none;' : ''}"></div>
                        ${thumbUrl ? (item.type === 'video' && !thumbUrl.toLowerCase().endsWith('.jpg') && !thumbUrl.toLowerCase().endsWith('.jpeg') && !thumbUrl.toLowerCase().endsWith('.png') && !thumbUrl.toLowerCase().endsWith('.gif') && !thumbUrl.toLowerCase().endsWith('.webp')
                            ? `<video ${srcAttr} ${widthAttr} ${heightAttr} muted loop playsinline class="${loadedClass}"${loadedStyle} onerror="console.log('Video thumbnail failed:', '${thumbUrl}')" onloadeddata="this.classList.add('loaded'); this.style.opacity = '1'; if (!this.dataset.src) { this.play(); }"></video>`
                            : `<img ${srcAttr} ${widthAttr} ${heightAttr} loading="lazy"${index < 12 ? ' fetchpriority="high"' : ''} alt="${item.filename}" class="${loadedClass}"${loadedStyle} onload="this.classList.add('loaded'); this.style.opacity = '1';" onerror="console.log('Thumbnail failed:', '${thumbUrl}')">`
                        ) : ''}
                        ${item.type === 'video' ? '<div class="play-icon"></div>' : ''}
                    </div>
                    <div class="filename">${item.filename}</div>
                    <div class="metadata">${item.metadata || 'Unknown'}</div>
                </div>
                `;
            }).join('');
            
            // Enable lazy loading immediately after render for better mobile performance
            if (isInitialLoad) {
                // Small delay to ensure DOM is ready
                setTimeout(() => {
                    setupLazyLoading();
                }, 100);
            } else {
                setupLazyLoading();
            }
            
            // Add hover effects
            setupHoverEffects();
        }

        // Store observer globally so we can disconnect/reconnect it
        let lazyLoadingObserver = null;

        function setupLazyLoading() {
            // Increase rootMargin on mobile for better performance (load earlier)
            const isMobile = window.innerWidth <= 768;
            const observerOptions = {
                root: null,
                rootMargin: isMobile ? '400px' : '200px', // Load much earlier on mobile
                threshold: 0.01
            };

            lazyLoadingObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const thumbnail = entry.target.querySelector('.thumbnail');
                    const placeholder = thumbnail?.querySelector('.thumbnail-placeholder');
                    const img = thumbnail?.querySelector('img');
                    const video = thumbnail?.querySelector('video');
                    
                    // Check if lightbox is open - don't unload items when lightbox is active
                    const lightbox = document.getElementById('lightbox');
                    const isLightboxOpen = lightbox && lightbox.classList.contains('active');
                    
                    if (entry.isIntersecting) {
                        // Item is in view - show placeholder and load media
                        if (placeholder) {
                            placeholder.style.display = 'block';
                        }
                        
                        // Lazy load images
                        if (img && img.dataset.src) {
                            img.style.opacity = '0';
                            img.src = img.dataset.src;
                            img.onload = () => {
                                img.classList.add('loaded');
                                img.style.opacity = '1';
                                // Hide placeholder once image loads
                                if (placeholder) {
                                    placeholder.style.display = 'none';
                                }
                            };
                            delete img.dataset.src;
                        } else if (img && img.src && !img.classList.contains('loaded')) {
                            // Image already has src but not loaded yet
                            img.style.opacity = '0';
                            img.onload = () => {
                                img.classList.add('loaded');
                                img.style.opacity = '1';
                                if (placeholder) {
                                    placeholder.style.display = 'none';
                                }
                            };
                        }
                        
                        // Lazy load videos
                        if (video && video.dataset.src && !video.classList.contains('loaded')) {
                            video.style.opacity = '0';
                            video.src = video.dataset.src;
                            video.autoplay = true;
                            video.playsInline = true;
                            video.onloadeddata = () => {
                                video.classList.add('loaded');
                                video.style.opacity = '1';
                                // Play video once loaded
                                video.play().catch(e => {
                                    // Autoplay may be blocked, that's okay
                                    console.log('Video autoplay blocked:', e);
                                });
                                // Hide placeholder once video loads
                                if (placeholder) {
                                    placeholder.style.display = 'none';
                                }
                            };
                            delete video.dataset.src;
                        } else if (video && video.src && !video.classList.contains('loaded')) {
                            // Video already has src but not loaded yet
                            video.style.opacity = '0';
                            video.onloadeddata = () => {
                                video.classList.add('loaded');
                                video.style.opacity = '1';
                                if (placeholder) {
                                    placeholder.style.display = 'none';
                                }
                            };
                        }
                    } else {
                        // Item is out of view - but don't unload if lightbox is open
                        if (!isLightboxOpen) {
                            // Only unload when lightbox is closed
                            if (img && img.classList.contains('loaded')) {
                                img.classList.remove('loaded');
                                img.style.opacity = '0';
                                // Restore data-src for reloading
                                if (img.src && !img.dataset.src) {
                                    img.dataset.src = img.src;
                                    img.src = '';
                                }
                            }
                            if (video && video.classList.contains('loaded')) {
                                video.classList.remove('loaded');
                                video.style.opacity = '0';
                                video.pause();
                                // Restore data-src for reloading
                                if (video.src && !video.dataset.src) {
                                    video.dataset.src = video.src;
                                    video.src = '';
                                }
                            }
                            // Show placeholder when out of view
                            if (placeholder) {
                                placeholder.style.display = 'block';
                            }
                        }
                    }
                });
            }, observerOptions);

            // Wait a bit for DOM to be ready, then observe all items
            setTimeout(() => {
                document.querySelectorAll('.item').forEach(item => {
                    lazyLoadingObserver.observe(item);
                });
            }, 100);
        }
        
        // Function to force load all grid items (used when lightbox opens)
        function forceLoadAllGridItems() {
            document.querySelectorAll('.item').forEach(item => {
                const thumbnail = item.querySelector('.thumbnail');
                if (!thumbnail) return;
                
                const img = thumbnail.querySelector('img');
                const video = thumbnail.querySelector('video');
                const placeholder = thumbnail.querySelector('.thumbnail-placeholder');
                
                // Force load images
                if (img) {
                    // If image has data-src, it needs to be loaded
                    if (img.dataset.src) {
                        img.style.opacity = '0';
                        const srcToLoad = img.dataset.src;
                        img.src = srcToLoad;
                        img.onload = () => {
                            img.classList.add('loaded');
                            img.style.opacity = '1';
                            if (placeholder) {
                                placeholder.style.display = 'none';
                            }
                        };
                        img.onerror = () => {
                            // If image fails to load, keep placeholder visible
                            if (placeholder) {
                                placeholder.style.display = 'block';
                            }
                        };
                        delete img.dataset.src;
                    } 
                    // If image has src but isn't marked as loaded, ensure it's visible
                    else if (img.src) {
                        if (!img.classList.contains('loaded')) {
                            // Image might be loading - wait for it
                            if (img.complete) {
                                img.classList.add('loaded');
                                img.style.opacity = '1';
                                if (placeholder) {
                                    placeholder.style.display = 'none';
                                }
                            } else {
                                img.onload = () => {
                                    img.classList.add('loaded');
                                    img.style.opacity = '1';
                                    if (placeholder) {
                                        placeholder.style.display = 'none';
                                    }
                                };
                            }
                        } else {
                            // Already loaded - just ensure visible
                            img.style.opacity = '1';
                            if (placeholder) {
                                placeholder.style.display = 'none';
                            }
                        }
                    }
                }
                
                // Force load videos
                if (video) {
                    if (video.dataset.src) {
                        video.style.opacity = '0';
                        const srcToLoad = video.dataset.src;
                        video.src = srcToLoad;
                        video.onloadeddata = () => {
                            video.classList.add('loaded');
                            video.style.opacity = '1';
                            if (placeholder) {
                                placeholder.style.display = 'none';
                            }
                        };
                        video.onerror = () => {
                            if (placeholder) {
                                placeholder.style.display = 'block';
                            }
                        };
                        delete video.dataset.src;
                    } else if (video.src) {
                        if (!video.classList.contains('loaded')) {
                            if (video.readyState >= 2) { // HAVE_CURRENT_DATA
                                video.classList.add('loaded');
                                video.style.opacity = '1';
                                if (placeholder) {
                                    placeholder.style.display = 'none';
                                }
                            } else {
                                video.onloadeddata = () => {
                                    video.classList.add('loaded');
                                    video.style.opacity = '1';
                                    if (placeholder) {
                                        placeholder.style.display = 'none';
                                    }
                                };
                            }
                        } else {
                            video.style.opacity = '1';
                            if (placeholder) {
                                placeholder.style.display = 'none';
                            }
                        }
                    }
                }
            });
        }
        

        function setupHoverEffects() {
            const gallery = document.getElementById('grid');
            const items = gallery.querySelectorAll('.item');
            const searchInput = document.getElementById('searchInput');
            const searchClose = document.getElementById('searchClose');
            const lightbox = document.getElementById('lightbox');
            
            items.forEach((item, index) => {
                if (index >= portfolioData.length) return;
                const itemData = portfolioData[index];
                
                item.addEventListener('mouseenter', () => {
                    // Only update if lightbox is not open and search is not focused/active
                    if (!lightbox.classList.contains('active') && document.activeElement !== searchInput) {
                        // Update animated text to show filename
                        const animatedText = document.getElementById('animatedSearchText');
                        if (animatedText) {
                            const span = animatedText.querySelector('span');
                            if (span) {
                                span.textContent = itemData.filename;
                            }
                        }
                        // Hide animated text wrapper
                        const inputWrapper = document.querySelector('.search-bar__input-wrapper');
                        if (inputWrapper) {
                            inputWrapper.classList.add('hidden');
                        }
                        searchInput.value = itemData.filename;
                        searchInput.placeholder = '';
                        searchClose.classList.add('visible'); // Show X button
                    }
                });
                
                item.addEventListener('mouseleave', () => {
                    // Only reset if lightbox is not open and search is not focused/active
                    if (!lightbox.classList.contains('active') && document.activeElement !== searchInput) {
                        if (searchInput.value === itemData.filename) {
                            searchInput.value = '';
                            searchInput.placeholder = '';
                            searchClose.classList.remove('visible'); // Hide X button
                            // Show animated text wrapper again and restore animation
                            const inputWrapper = document.querySelector('.search-bar__input-wrapper');
                            if (inputWrapper) {
                                inputWrapper.classList.remove('hidden');
                            }
                            // Restore animated text to first search term
                            const animatedText = document.getElementById('animatedSearchText');
                            if (animatedText && searchTerms.length > 0) {
                                const span = animatedText.querySelector('span');
                                if (span) {
                                    span.textContent = searchTerms[0];
                                }
                            }
                        }
                    }
                });
            });
        }

        function updateStats() {
            const totalItems = portfolioData.length;
            const totalImages = portfolioData.filter(item => item.type === 'image').length;
            const totalVideos = portfolioData.filter(item => item.type === 'video').length;
            const totalFolders = new Set(portfolioData.map(item => item.folder)).size;
            
            document.getElementById('stats').textContent = 
                `${totalItems} items • ${totalImages} images • ${totalVideos} videos • ${totalFolders} projects`;
        }

        function populateThumbnailFilmstrip() {
            const filmstripContainer = document.getElementById('filmstripContainer');
            const thumbnailFilmstrip = document.getElementById('thumbnailFilmstrip');
            
            // Create thumbnails for all items
            filmstripContainer.innerHTML = portfolioData.map((item, index) => {
                const thumbUrl = item.thumbnailUrl || (item.type === 'video' 
                    ? getS3Url(`thumbnails/${item.path}`)
                    : getS3Url(`thumbnails/${item.path.replace(/\.[^.]+$/, '.jpg')}`));
                
                const mediaTag = item.type === 'video'
                    ? `<video src="${thumbUrl}" muted loop playsinline></video>`
                    : `<img src="${thumbUrl}" alt="${item.filename}">`;
                
                return `
                    <div class="filmstrip-thumb ${index === currentIndex ? 'current' : ''}" 
                         data-index="${index}" 
                         onclick="openLightbox(${index})">
                        ${mediaTag}
                    </div>
                `;
            }).join('');
            
            // Scroll current thumbnail into view
            setTimeout(() => {
                const currentThumb = filmstripContainer.querySelector('.filmstrip-thumb.current');
                if (currentThumb) {
                    currentThumb.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                }
            }, 100);
            
            setupFilmstripAutoScroll();
        }
        
        function setupFilmstripAutoScroll() {
            const filmstripContainer = document.getElementById('filmstripContainer');
            const thumbnailFilmstrip = document.getElementById('thumbnailFilmstrip');
            let scrollInterval = null;
            
            // Auto-scroll when hovering near edges
            thumbnailFilmstrip.addEventListener('mouseenter', () => {
                const rect = thumbnailFilmstrip.getBoundingClientRect();
                
                thumbnailFilmstrip.addEventListener('mousemove', (e) => {
                    const mouseX = e.clientX - rect.left;
                    const filmstripWidth = rect.width;
                    const scrollThreshold = 80; // Larger threshold for easier activation
                    
                    // Clear any existing scroll interval
                    if (scrollInterval) {
                        clearInterval(scrollInterval);
                        scrollInterval = null;
                    }
                    
                    // Calculate scroll speed based on distance from edge (closer = faster)
                    let scrollSpeed = 0;
                    if (mouseX < scrollThreshold && filmstripContainer.scrollLeft > 0) {
                        // Left edge: speed increases as you get closer to edge
                        scrollSpeed = Math.max(1, Math.round((scrollThreshold - mouseX) / 10));
                    } else if (mouseX > filmstripWidth - scrollThreshold && 
                             filmstripContainer.scrollLeft < filmstripContainer.scrollWidth - filmstripContainer.clientWidth) {
                        // Right edge: speed increases as you get closer to edge
                        scrollSpeed = Math.max(1, Math.round((mouseX - (filmstripWidth - scrollThreshold)) / 10));
                    }
                    
                    if (scrollSpeed > 0) {
                        scrollInterval = setInterval(() => {
                            if (mouseX < scrollThreshold) {
                                filmstripContainer.scrollLeft -= scrollSpeed;
                                if (filmstripContainer.scrollLeft <= 0) {
                                    clearInterval(scrollInterval);
                                    scrollInterval = null;
                                }
                            } else {
                                filmstripContainer.scrollLeft += scrollSpeed;
                                if (filmstripContainer.scrollLeft >= filmstripContainer.scrollWidth - filmstripContainer.clientWidth) {
                                    clearInterval(scrollInterval);
                                    scrollInterval = null;
                                }
                            }
                        }, 8); // Higher frequency for smoother scrolling
                    }
                });
            });
            
            // Stop scrolling when mouse leaves
            thumbnailFilmstrip.addEventListener('mouseleave', () => {
                if (scrollInterval) {
                    clearInterval(scrollInterval);
                    scrollInterval = null;
                }
            });
        }

        function updateFilmstripCurrent() {
            const filmstripContainer = document.getElementById('filmstripContainer');
            const thumbs = filmstripContainer.querySelectorAll('.filmstrip-thumb');
            
            thumbs.forEach((thumb, index) => {
                if (index === currentIndex) {
                    thumb.classList.add('current');
                    thumb.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                } else {
                    thumb.classList.remove('current');
                }
            });
        }

        // Helper: Update all header bars with class
        function updateHeaderBars(className, add = true) {
            const headerBars = document.querySelectorAll('.header-bar');
            headerBars.forEach(bar => {
                if (add) {
                    bar.classList.add(className);
                } else {
                    bar.classList.remove(className);
                }
            });
        }

        // Function to recalculate lightbox media size on resize
        function recalculateLightboxMediaSize() {
            const lightbox = document.getElementById('lightbox');
            if (!lightbox || !lightbox.classList.contains('active')) return;
            
            const mediaContainer = document.getElementById('lightbox-media');
            if (!mediaContainer) return;
            
            const imageWrapper = mediaContainer.querySelector('.lightbox-image-wrapper');
            const videoWrapper = mediaContainer.querySelector('.video-player-wrapper');
            const item = portfolioData[currentIndex];
            
            if (!item) return;
            
            const itemWidth = parseInt(item.width) || 1920;
            const itemHeight = parseInt(item.height) || 1080;
            const aspectRatio = itemWidth / itemHeight;
            
            // Recalculate dimensions
            const maxWidth = window.innerWidth * 0.67; // Approximate 8 columns
            const maxHeight = window.innerHeight * 0.8; // 80vh
            
            let placeholderWidth, placeholderHeight;
            
            if (aspectRatio > 1) {
                placeholderWidth = Math.min(maxWidth, itemWidth);
                placeholderHeight = placeholderWidth / aspectRatio;
                if (placeholderHeight > maxHeight) {
                    placeholderHeight = maxHeight;
                    placeholderWidth = placeholderHeight * aspectRatio;
                }
            } else {
                placeholderHeight = Math.min(maxHeight, itemHeight);
                placeholderWidth = placeholderHeight * aspectRatio;
                if (placeholderWidth > maxWidth) {
                    placeholderWidth = maxWidth;
                    placeholderHeight = placeholderWidth / aspectRatio;
                }
            }
            
            // Update wrapper sizes - on mobile, let CSS handle width
            if (imageWrapper) {
                if (isMobile) {
                    imageWrapper.style.width = '100%';
                    imageWrapper.style.height = 'auto';
                    imageWrapper.style.aspectRatio = aspectRatio;
                } else {
                    imageWrapper.style.width = `${placeholderWidth}px`;
                    imageWrapper.style.height = `${placeholderHeight}px`;
                }
            }
            
            if (videoWrapper) {
                if (isMobile) {
                    videoWrapper.style.width = '100%';
                    videoWrapper.style.height = 'auto';
                    videoWrapper.style.aspectRatio = aspectRatio;
                } else {
                    videoWrapper.style.width = `${placeholderWidth}px`;
                    videoWrapper.style.height = `${placeholderHeight}px`;
                }
            }
        }
        
        // Resize handler for lightbox
        let lightboxResizeHandler = null;

        function openLightbox(index) {
            currentIndex = index;
            const item = portfolioData[index];
            const lightbox = document.getElementById('lightbox');
            const mediaContainer = document.getElementById('lightbox-media');
            const playerUI = document.getElementById('video-player-ui');
            const thumbnailFilmstrip = document.getElementById('thumbnailFilmstrip');
            const searchInput = document.getElementById('searchInput');
            const searchClose = document.getElementById('searchClose');
            
            // Ensure keyboard navigation is set up
            setupKeyboardNav();
            
            // Update search input with filename and show X button
            // But don't filter the grid - keep all items visible behind the lightbox
            if (searchInput) {
                searchInput.value = item.filename;
                searchInput.placeholder = '';
                // Update animated text to show filename
                const animatedText = document.getElementById('animatedSearchText');
                if (animatedText) {
                    const span = animatedText.querySelector('span');
                    if (span) {
                        span.textContent = item.filename;
                    }
                }
                // Hide animated text wrapper when value is set
                const inputWrapper = document.querySelector('.search-bar__input-wrapper');
                if (inputWrapper) {
                    inputWrapper.classList.add('hidden');
                }
                // Don't dispatch input event - we don't want to filter the grid
                // Just update the UI elements directly
                if (searchClose) {
                    searchClose.classList.add('visible');
                }
            }
            if (searchClose) {
                searchClose.classList.add('visible');
            }
            
            updateHeaderBars('header-bar--lightbox-mode', true);
            updateNavButtonHandlers();
            
            // Show thumbnail filmstrip
            thumbnailFilmstrip.classList.add('active');
            
            // Populate filmstrip on first open
            if (!thumbnailFilmstrip.dataset.populated) {
                populateThumbnailFilmstrip();
                thumbnailFilmstrip.dataset.populated = 'true';
            } else {
                updateFilmstripCurrent();
            }
            
            
            // Setup navigation button handlers
            // Navigation handled by updateNavButtonHandlers()
            
            // Update URL with unique slug
            updateLightboxURL(index);
            
            // Preload previous and next items for fast navigation
            preloadAdjacentItems(index);

            // Create the media element - use URL from JSON, fallback to building it
            const workUrl = item.url || getS3Url(item.path);
            
            // Calculate dimensions for media elements
            const itemWidth = parseInt(item.width) || 1920;
            const itemHeight = parseInt(item.height) || 1080;
            const aspectRatio = itemWidth / itemHeight;
            
            // Calculate dimensions respecting max-width: 100% and max-height: 80vh
            // This matches how the image/video will be sized
            // Check if mobile (viewport width <= 768px)
            const isMobile = window.innerWidth <= 768;
            let maxWidth, maxHeight;
            
            if (isMobile) {
                // On mobile, use full width minus 2em padding
                maxWidth = window.innerWidth - (2 * parseFloat(getComputedStyle(document.documentElement).fontSize) || 16);
                maxHeight = window.innerHeight * 0.8; // 80vh
            } else {
                maxWidth = window.innerWidth * 0.67; // Approximate 8 columns
                maxHeight = window.innerHeight * 0.8; // 80vh
            }
            
            let placeholderWidth, placeholderHeight;
            
            // Calculate to fit within constraints while maintaining aspect ratio
            if (aspectRatio > 1) {
                // Landscape: width-constrained
                placeholderWidth = Math.min(maxWidth, itemWidth);
                placeholderHeight = placeholderWidth / aspectRatio;
                if (placeholderHeight > maxHeight) {
                    placeholderHeight = maxHeight;
                    placeholderWidth = placeholderHeight * aspectRatio;
                }
            } else {
                // Portrait: height-constrained
                placeholderHeight = Math.min(maxHeight, itemHeight);
                placeholderWidth = placeholderHeight * aspectRatio;
                if (placeholderWidth > maxWidth) {
                    placeholderWidth = maxWidth;
                    placeholderHeight = placeholderWidth / aspectRatio;
                }
            }
            
            // Store dimensions for media elements - use exact calculated dimensions
            const mediaWidth = `${placeholderWidth}px`;
            const mediaHeight = `${placeholderHeight}px`;
            
            // Clear container
            mediaContainer.innerHTML = '';
            
            // Handle special item - show text content
            if (item.isSpecial) {
                const textContent = document.createElement('div');
                textContent.className = 'special-item-content';
                
                textContent.innerHTML = `
                    <div style="margin-bottom: 30px;">
                        <h2>About</h2>
                        <p>Not really a studio. No business plan. Just a place to channel my imagination, mix my skills and interests, and make as much as I can—for myself and as a creative plug-in for agencies and clients. Ideas. Advertising. CGI. Graphic design. Art. Digital things. Physical things. All the things.</p>
                    </div>
                    
                    <div style="margin-bottom: 30px;">
                        <h2>Core Services</h2>
                        <p>3D modelling & rendering, Brand creation, Brand design systems, Creative direction, Editing and directing, Integrated advertising, Motion design, Pitch machine, Product and packaging, Spatial and experiential design, Web development, World building, Cool shit</p>
                    </div>
                    
                    <div style="margin-bottom: 30px;">
                        <h2>Selected Awards</h2>
                        <p>Cannes Gold Lion × 1, Cannes Silver Lion × 4, Cannes Bronze Lion × 1, D&AD Yellow Pencil × 3, D&AD Graphite Pencil × 4, D&AD Wood Pencil × 7, Beazley Product Design of the Year</p>
                    </div>
                `;
                
                mediaContainer.appendChild(textContent);
                
                // Explicitly hide video player UI for special items
                if (playerUI) {
                    playerUI.classList.remove('active');
                }
                lightbox.removeAttribute('data-has-video');
                
                // Save current scroll position before opening lightbox
                const scrollY = window.scrollY;
                document.body.style.position = 'fixed';
                document.body.style.top = `-${scrollY}px`;
                document.body.style.width = '100%';
                document.body.classList.add('lightbox-open');
                document.body.style.overflow = 'hidden';
                document.body.dataset.scrollY = scrollY;
                
                // Disconnect lazy loading observer to prevent unloading items
                if (lazyLoadingObserver) {
                    lazyLoadingObserver.disconnect();
                }
                
                // Immediately force load all grid items so they're visible behind the blur
                forceLoadAllGridItems();
                
                // Ensure lightbox starts at bottom position with opacity 0
                lightbox.classList.remove('slide-in');
                lightbox.classList.remove('sliding-up');
                lightbox.style.transform = 'translateY(100vh)';
                lightbox.style.opacity = '0';
                lightbox.style.transition = 'transform 0.35s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.35s cubic-bezier(0.4, 0, 0.2, 1)';
                
                lightbox.classList.add('active');
                
                // Trigger slide-in and fade-in animation
                requestAnimationFrame(() => {
                    lightbox.style.transform = '';
                    lightbox.style.opacity = '';
                    lightbox.classList.add('slide-in');
                    setTimeout(() => {
                        lightbox.classList.add('media-visible');
                    }, 50);
                });
                
                // Add resize handler
                if (lightboxResizeHandler) {
                    window.removeEventListener('resize', lightboxResizeHandler);
                }
                lightboxResizeHandler = () => {
                    requestAnimationFrame(recalculateLightboxMediaSize);
                };
                window.addEventListener('resize', lightboxResizeHandler);
                return;
            }
            
            if (item.type === 'image') {
                // Check if mobile
                const isMobile = window.innerWidth <= 768;
                
                // Create wrapper div for image
                const imageWrapper = document.createElement('div');
                imageWrapper.className = 'lightbox-image-wrapper';
                if (isMobile) {
                    // On mobile, let CSS handle width (100%), only set height
                    imageWrapper.style.cssText = `
                        position: relative;
                        display: block;
                        border-radius: 6px !important;
                        overflow: hidden !important;
                        width: 100%;
                        height: auto;
                        aspect-ratio: ${aspectRatio};
                    `;
                } else {
                    imageWrapper.style.cssText = `
                        position: relative;
                        display: inline-block;
                        border-radius: 6px !important;
                        overflow: hidden !important;
                        width: ${mediaWidth};
                        height: ${mediaHeight};
                    `;
                }
                
                const img = document.createElement('img');
                img.src = workUrl;
                img.alt = item.filename;
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'contain';
                img.style.display = 'block';
                
                if (!isMobile) {
                    img.onload = () => {
                        // Adjust wrapper to match image's actual rendered size (desktop only)
                        const rect = img.getBoundingClientRect();
                        imageWrapper.style.width = rect.width + 'px';
                        imageWrapper.style.height = rect.height + 'px';
                    };
                }
                
                imageWrapper.appendChild(img);
                mediaContainer.appendChild(imageWrapper);
                playerUI.classList.remove('active');
                lightbox.removeAttribute('data-has-video');
            } else {
                // PROFESSIONAL APPROACH: Video wrapper with position: relative, progress bar as absolute child
                // This is how professional video players work - progress bar is always relative to video container
                
                // Check if mobile
                const isMobile = window.innerWidth <= 768;
                
                // PROFESSIONAL APPROACH: Wrapper matches video's exact rendered size
                // Create wrapper div with position: relative
                const videoWrapper = document.createElement('div');
                videoWrapper.className = 'video-player-wrapper';
                // Set wrapper to match video dimensions exactly
                if (isMobile) {
                    // On mobile, let CSS handle width (100%), only set aspect ratio
                    videoWrapper.style.cssText = `
                        position: relative;
                        display: block;
                        width: 100%;
                        height: auto;
                        aspect-ratio: ${aspectRatio};
                        margin: 0;
                        padding: 0;
                        line-height: 0;
                    `;
                } else {
                    videoWrapper.style.cssText = `
                        position: relative;
                        display: inline-block;
                        width: ${mediaWidth};
                        height: ${mediaHeight};
                        margin: 0;
                        padding: 0;
                        line-height: 0;
                    `;
                }
                
                // Create video element
                const video = document.createElement('video');
                video.src = workUrl;
                video.id = 'lightbox-video';
                video.autoplay = true;
                video.muted = true;
                video.loop = true;
                video.style.cssText = `
                    width: 100%;
                    height: 100%;
                    object-fit: contain;
                    display: block;
                    margin: 0;
                    padding: 0;
                    position: relative;
                    z-index: 1;
                    border-radius: 6px;
                    -webkit-border-radius: 6px;
                    -moz-border-radius: 6px;
                    clip-path: inset(0 round 6px);
                    -webkit-clip-path: inset(0 round 6px);
                `;
                
                // Create progress bar - absolutely positioned within wrapper at bottom
                const progressLine = document.createElement('div');
                progressLine.id = 'progressLine';
                progressLine.className = 'video-progress-bar';
                progressLine.style.cssText = `
                    position: absolute;
                    bottom: 0;
                    left: 0;
                    width: 100%;
                    height: 6px;
                    background: rgba(128, 128, 128, 0.3);
                    z-index: 1000;
                    margin: 0;
                    padding: 0;
                    pointer-events: auto;
                    cursor: pointer;
                    opacity: 0;
                    visibility: hidden;
                    transition: opacity 0.3s ease, visibility 0.3s ease;
                `;
                
                const progressFill = document.createElement('div');
                progressFill.className = 'progress-fill-line';
                progressFill.id = 'progressFill';
                progressFill.style.cssText = `
                    height: 100%;
                    width: 0%;
                    background: rgba(200, 200, 200, 0.8);
                    transition: width 0.1s ease;
                    pointer-events: none;
                `;
                progressLine.appendChild(progressFill);
                
                // Add video and progress bar to wrapper
                videoWrapper.appendChild(video);
                videoWrapper.appendChild(progressLine);
                
                // Sync wrapper size to video's rendered size after load
                const syncWrapperToVideo = () => {
                    requestAnimationFrame(() => {
                        const videoRect = video.getBoundingClientRect();
                        if (videoRect.width > 0 && videoRect.height > 0) {
                            videoWrapper.style.width = `${videoRect.width}px`;
                            videoWrapper.style.height = `${videoRect.height}px`;
                        }
                    });
                };
                
                video.onloadeddata = syncWrapperToVideo;
                video.onresize = syncWrapperToVideo;
                window.addEventListener('resize', syncWrapperToVideo);
                
                // Add wrapper to container
                mediaContainer.appendChild(videoWrapper);
                
                // Don't show controls immediately - they'll show on mousemove
                // playerUI.classList.add('active');
                lightbox.setAttribute('data-has-video', 'true');
            }
            
            // Save current scroll position before opening lightbox
            const scrollY = window.scrollY;
            document.body.style.position = 'fixed';
            document.body.style.top = `-${scrollY}px`;
            document.body.style.width = '100%';
            
            // Show lightbox and trigger slide-up animation with fade
            // First, ensure lightbox starts at bottom position with opacity 0
            lightbox.classList.remove('slide-in');
            lightbox.classList.remove('sliding-up');
            lightbox.style.transform = 'translateY(100vh)';
            lightbox.style.opacity = '0';
            lightbox.style.transition = 'transform 0.35s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.35s cubic-bezier(0.4, 0, 0.2, 1)';
            
            // Make it visible but still off-screen and transparent
            lightbox.classList.add('active');
            document.body.classList.add('lightbox-open');
            document.body.style.overflow = 'hidden';
            
            // Disable scroll on page wrapper/grid
            const pageWrapper = document.querySelector('.page-wrapper');
            if (pageWrapper) {
                pageWrapper.style.overflow = 'hidden';
            }
            
            // Store scroll position for restoration
            document.body.dataset.scrollY = scrollY;
            
            // Add resize handler for dynamic resizing
            if (lightboxResizeHandler) {
                window.removeEventListener('resize', lightboxResizeHandler);
            }
            lightboxResizeHandler = () => {
                requestAnimationFrame(recalculateLightboxMediaSize);
            };
            window.addEventListener('resize', lightboxResizeHandler);
            
            // Trigger slide-in and fade-in animation on next frame
            requestAnimationFrame(() => {
                // Clear inline styles to let CSS transition handle it
                lightbox.style.transform = '';
                lightbox.style.opacity = '';
                lightbox.classList.add('slide-in');
                // Fade in media as background slides in
                setTimeout(() => {
                    lightbox.classList.add('media-visible');
                }, 50);
            });
            
            // Setup video player if needed
            if (item.type === 'video') {
                // Hide controls when navigating to new video (they'll show on mousemove)
                const playerUI = document.getElementById('video-player-ui');
                if (playerUI) {
                    playerUI.classList.remove('active');
                    // Hide after brief moment to allow any brief appearance to fade
                    setTimeout(() => {
                        playerUI.classList.remove('active');
                    }, 500);
                }
                setupVideoPlayer(item);
            }
        }

        function setupVideoPlayer(item) {
            const video = document.getElementById('lightbox-video');
            const playPauseBtn = document.getElementById('playPauseBtn');
            const progressFill = document.getElementById('progressFill');
            const muteBtn = document.getElementById('muteBtn');
            const playerUI = document.getElementById('video-player-ui');
            const lightboxContent = document.querySelector('.lightbox-content');
            const progressLine = document.getElementById('progressLine');
            const videoWrapper = video ? video.closest('.video-player-wrapper') : null;
            
            // Position controls so they align to the video edges (even when video is narrower than the container)
            const positionControls = () => {
                if (!playerUI || !videoWrapper || !lightboxContent) return;
                const wrapperRect = videoWrapper.getBoundingClientRect();
                const contentRect = lightboxContent.getBoundingClientRect();
                playerUI.style.left = `${wrapperRect.left - contentRect.left}px`;
                playerUI.style.width = `${wrapperRect.width}px`;
            };
            
            // Function to update video wrapper size to match actual video dimensions
            function updateVideoWrapperSize() {
                if (!video || !videoWrapper) return;
                
                requestAnimationFrame(() => {
                    const rect = video.getBoundingClientRect();
                    if (rect.width > 0 && rect.height > 0) {
                        videoWrapper.style.width = Math.round(rect.width) + 'px';
                        videoWrapper.style.height = Math.round(rect.height) + 'px';
                    }
                });
            }
            
            // Update wrapper size when video loads and on resize
            if (video) {
                video.addEventListener('loadedmetadata', updateVideoWrapperSize);
                video.addEventListener('loadeddata', updateVideoWrapperSize);
                video.addEventListener('resize', updateVideoWrapperSize);
                window.addEventListener('resize', updateVideoWrapperSize);
                
                // Initial update after a short delay to ensure video is rendered
                setTimeout(updateVideoWrapperSize, 100);
                
                // Keep controls aligned when video size is known
                video.addEventListener('loadeddata', positionControls);
                video.addEventListener('resize', positionControls);
            }
            
            // Align controls to video edges on load and resize
            positionControls();
            window.addEventListener('resize', positionControls);
            
            // Q key toggle for progress bar visibility - global listener
            let progressBarVisible = true;
            
            // Disabled: Remove progress bar toggle listener (development guide)
            // const existingToggle = window._progressBarToggle;
            // if (existingToggle) {
            //     document.removeEventListener('keydown', existingToggle);
            // }
            
            // Disabled: Q key for progress bar toggle (development guide)
            // const toggleProgressBar = (e) => {
            //     // Only toggle when lightbox is active and Q key is pressed
            //     if (lightbox && lightbox.classList.contains('active') && (e.key === 'q' || e.key === 'Q')) {
            //         e.preventDefault();
            //         e.stopPropagation();
            //         progressBarVisible = !progressBarVisible;
            //         if (progressLine) {
            //             if (progressBarVisible) {
            //                 progressLine.classList.remove('hidden');
            //                 console.log('Progress bar shown');
            //             } else {
            //                 progressLine.classList.add('hidden');
            //                 console.log('Progress bar hidden');
            //             }
            //         }
            //     }
            // };
            // 
            // // Store reference globally so we can remove it later
            // window._progressBarToggle = toggleProgressBar;
            // document.addEventListener('keydown', toggleProgressBar);
            
            // Set audio to be on by default
            video.muted = false;
            
            let hideControlsTimer = null;
            const HIDE_DELAY = 2000; // Hide after 2 seconds of no movement

            // Simple show/hide logic: show on mousemove, hide after delay
            function showControls() {
                playerUI.classList.add('active');
                
                // Show progress bar
                if (progressLine) {
                    progressLine.style.opacity = '1';
                    progressLine.style.visibility = 'visible';
                }
                
                // Clear any existing hide timer
                if (hideControlsTimer) {
                    clearTimeout(hideControlsTimer);
                }
                
                // Set timer to hide after delay
                hideControlsTimer = setTimeout(() => {
                    playerUI.classList.remove('active');
                    // Hide progress bar
                    if (progressLine) {
                        progressLine.style.opacity = '0';
                        progressLine.style.visibility = 'hidden';
                    }
                    hideControlsTimer = null;
                }, HIDE_DELAY);
            }

            // Hide controls immediately (used when navigating to new item)
            function hideControlsNow() {
                if (hideControlsTimer) {
                    clearTimeout(hideControlsTimer);
                    hideControlsTimer = null;
                }
                playerUI.classList.remove('active');
                // Hide progress bar
                if (progressLine) {
                    progressLine.style.opacity = '0';
                    progressLine.style.visibility = 'hidden';
                }
            }

            // Start with controls hidden
            playerUI.classList.remove('active');
            
            // Start with progress bar hidden
            if (progressLine) {
                progressLine.style.opacity = '0';
                progressLine.style.visibility = 'hidden';
            }
            
            // Show controls on mouse movement
            lightboxContent.addEventListener('mousemove', showControls);
            
            // Hide controls when mouse leaves video area
            lightboxContent.addEventListener('mouseleave', hideControlsNow);

            // Play/Pause
            playPauseBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent lightbox close
                if (video.paused) {
                    video.play();
                    playPauseBtn.textContent = '⏸';
                    // Controls will auto-hide based on cursor movement
                } else {
                    video.pause();
                    playPauseBtn.textContent = '▶';
                    // Controls will auto-hide based on cursor movement
                }
            };

            // Progress bar
            function updateProgress() {
                const progress = (video.currentTime / video.duration) * 100;
                progressFill.style.width = progress + '%';
            }

            // Seek on progress bar click
            progressLine.onclick = (e) => {
                e.stopPropagation(); // Prevent lightbox close
                const rect = progressLine.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const percentage = clickX / rect.width;
                video.currentTime = percentage * video.duration;
            };

            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }



            // Mute/Unmute
            muteBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent lightbox close
                if (video.muted) {
                    video.muted = false;
                    muteBtn.innerHTML = '<span class="material-icons mute-icon">volume_up</span>';
                } else {
                    video.muted = true;
                    muteBtn.innerHTML = '<span class="material-icons mute-icon">volume_off</span>';
                }
            };


            // Video event listeners
            video.addEventListener('timeupdate', updateProgress);
            video.addEventListener('loadedmetadata', updateProgress);
            video.addEventListener('play', () => playPauseBtn.textContent = '⏸');
            video.addEventListener('pause', () => playPauseBtn.textContent = '▶');
        }

        function closeLightboxKeepFilter() {
            const lightbox = document.getElementById('lightbox');
            const thumbnailFilmstrip = document.getElementById('thumbnailFilmstrip');
            const searchInput = document.getElementById('searchInput');
            const searchClose = document.getElementById('searchClose');
            
            // Re-enable zoom buttons if they were disabled (info page)
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            if (zoomInBtn) {
                zoomInBtn.classList.remove('disabled');
                zoomInBtn.style.pointerEvents = '';
            }
            if (zoomOutBtn) {
                zoomOutBtn.classList.remove('disabled');
                zoomOutBtn.style.pointerEvents = '';
            }
            
            // Remove info page marker
            lightbox.removeAttribute('data-info-page');
            
            // Slide up and fade out animation - similar to info modal
            lightbox.style.transition = 'transform 0.35s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.35s cubic-bezier(0.4, 0, 0.2, 1)';
            lightbox.style.transform = 'translateY(-100vh)';
            lightbox.style.opacity = '0';
            lightbox.classList.add('sliding-up');
            lightbox.classList.remove('slide-in');
            lightbox.classList.remove('media-visible');
            
            // Remove resize handler
            if (lightboxResizeHandler) {
                window.removeEventListener('resize', lightboxResizeHandler);
                lightboxResizeHandler = null;
            }
            
            
            // Wait for slide-up and fade-out animation to complete before hiding
            setTimeout(() => {
                lightbox.classList.remove('active');
                lightbox.classList.remove('sliding-up');
                lightbox.style.transform = '';
                lightbox.style.opacity = '';
                lightbox.style.transition = '';
                document.body.classList.remove('lightbox-open');
                
                // Restore scroll position
                const scrollY = document.body.dataset.scrollY || 0;
                document.body.style.position = '';
                document.body.style.top = '';
                document.body.style.width = '';
                document.body.style.overflow = '';
                window.scrollTo(0, parseInt(scrollY) || 0);
                delete document.body.dataset.scrollY;
                
                // Re-enable scroll on page wrapper/grid
                const pageWrapper = document.querySelector('.page-wrapper');
                if (pageWrapper) {
                    pageWrapper.style.overflow = '';
                }
                
                // Reconnect lazy loading observer after a short delay
                // This allows the scroll position to be restored first
                setTimeout(() => {
                    if (lazyLoadingObserver) {
                        document.querySelectorAll('.item').forEach(item => {
                            lazyLoadingObserver.observe(item);
                        });
                    }
                }, 100);
            }, 350); // Match the transition duration
            
            document.getElementById('video-player-ui').classList.remove('active');
            
            updateHeaderBars('header-bar--lightbox-mode', false);
            updateNavButtonHandlers();
            thumbnailFilmstrip.classList.remove('active');
            
            // Clear search input if it matches the current item's filename
            if (searchInput && currentIndex < portfolioData.length) {
                const currentItem = portfolioData[currentIndex];
                if (searchInput.value === currentItem.filename) {
                    searchInput.value = '';
                    searchInput.placeholder = 'Search leslie.work';
                    if (searchClose) {
                        searchClose.classList.remove('visible');
                    }
                    // Show animated text wrapper again and restore animation
                    const inputWrapper = document.querySelector('.search-bar__input-wrapper');
                    if (inputWrapper) {
                        inputWrapper.classList.remove('hidden');
                    }
                    // Restore animated text to first search term
                    const animatedText = document.getElementById('animatedSearchText');
                    if (animatedText && searchTerms.length > 0) {
                        const span = animatedText.querySelector('span');
                        if (span) {
                            span.textContent = searchTerms[0];
                        }
                    }
                    // Ensure grid shows all items
                    filterGrid('');
                }
            }
            
            // Pause any video
            const video = document.querySelector('#lightbox video');
            if (video) video.pause();
            
            // Reset URL hash when closing lightbox
            if (window.location.hash) {
                window.history.replaceState(null, '', window.location.pathname + window.location.search);
            }
            
            // No auto-scroll - keep it simple
        }

        function closeLightbox() {
            // Just use the keep filter version
            closeLightboxKeepFilter();
        }

        function navigate(direction) {
            currentIndex = (currentIndex + direction + portfolioData.length) % portfolioData.length;
            const item = portfolioData[currentIndex];
            const searchInput = document.getElementById('searchInput');
            
            // Update search input with new filename
            if (searchInput) {
                searchInput.value = item.filename;
                searchInput.placeholder = '';
                // Update animated text to show filename
                const animatedText = document.getElementById('animatedSearchText');
                if (animatedText) {
                    const span = animatedText.querySelector('span');
                    if (span) {
                        span.textContent = item.filename;
                    }
                }
            }
            
            // Update filmstrip highlight
            updateFilmstripCurrent();
            
            // Update URL
            updateLightboxURL(currentIndex);
            
            // Preload adjacent items
            preloadAdjacentItems(currentIndex);
            
            openLightbox(currentIndex);
        }
        
        // Generate unique slug from filename
        function generateSlug(filename) {
            return filename
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, '-')
                .replace(/^-+|-+$/g, '');
        }
        
        // Update URL with unique slug for current item
        function updateLightboxURL(index) {
            if (index >= 0 && index < portfolioData.length) {
                const item = portfolioData[index];
                const slug = generateSlug(item.filename);
                const newUrl = `#${slug}-${index}`;
                if (window.location.hash !== newUrl) {
                    window.history.replaceState(null, '', newUrl);
                }
            }
        }
        
        // Preload previous and next images/videos for fast navigation
        function preloadAdjacentItems(currentIndex) {
            if (!portfolioData || portfolioData.length === 0) return;
            
            const preloadIndexes = [
                (currentIndex - 1 + portfolioData.length) % portfolioData.length, // Previous
                (currentIndex + 1) % portfolioData.length // Next
            ];
            
            preloadIndexes.forEach(index => {
                const item = portfolioData[index];
                if (!item) return;
                
                const workUrl = item.url || getS3Url(item.path);
                
                if (item.type === 'image') {
                    const img = new Image();
                    img.src = workUrl;
                } else if (item.type === 'video') {
                    const video = document.createElement('video');
                    video.src = workUrl;
                    video.preload = 'auto';
                    // Don't append to DOM, just preload
                }
            });
        }
        
        // Check URL on page load and open lightbox if hash exists
        function checkURLHash() {
            const hash = window.location.hash;
            if (hash && portfolioData && portfolioData.length > 0) {
                // Extract index from hash (format: #slug-123)
                const match = hash.match(/-(\d+)$/);
                if (match) {
                    const index = parseInt(match[1]);
                    if (index >= 0 && index < portfolioData.length) {
                        // Small delay to ensure page is loaded and gallery is rendered
                        setTimeout(() => {
                            openLightbox(index);
                        }, 300);
                    }
                }
            }
        }

        // Keyboard navigation for lightbox - use a single event listener
        let keyboardNavHandler = null;
        
        function setupKeyboardNav() {
            // Remove existing handler if it exists
            if (keyboardNavHandler) {
                document.removeEventListener('keydown', keyboardNavHandler);
            }
            
            // Create new handler
            keyboardNavHandler = function(e) {
                const lightbox = document.getElementById('lightbox');
                if (!lightbox) return;
                
                const isActive = lightbox.classList.contains('active');
                if (!isActive) return;
                
                // Don't interfere if user is typing in an input field (except Escape)
                const activeElement = document.activeElement;
                const isInputFocused = activeElement && (
                    activeElement.tagName === 'INPUT' || 
                    activeElement.tagName === 'TEXTAREA' ||
                    activeElement.isContentEditable
                );
                
                // Always allow Escape to close, even when typing
                if (e.key === 'Escape' || e.keyCode === 27) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (typeof closeLightbox === 'function') {
                        closeLightbox();
                    }
                    return;
                }
                
                // For arrow keys, only work if not typing in an input
                if (isInputFocused) return;
                
                if (e.key === 'ArrowLeft' || e.keyCode === 37) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (typeof navigate === 'function') {
                        navigate(-1);
                    }
                    return;
                }
                
                if (e.key === 'ArrowRight' || e.keyCode === 39) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (typeof navigate === 'function') {
                        navigate(1);
                    }
                    return;
                }
            };
            
            // Add the event listener
            document.addEventListener('keydown', keyboardNavHandler);
        }

        // Close lightbox on outside click
        document.getElementById('lightbox').addEventListener('click', (e) => {
            if (e.target.id === 'lightbox') closeLightbox();
        });

        // Dark mode toggle functionality
        function initDarkModeToggle() {
            const darkModeToggle = document.getElementById('darkModeToggle');
            if (!darkModeToggle) return;
            
            // Default to dark mode on first load
            const savedPreference = localStorage.getItem('darkMode');
            // If no saved preference, default to dark mode (true)
            // If saved preference exists, use it
            const isDarkMode = savedPreference === null ? true : savedPreference === 'true';
            if (isDarkMode) {
                document.body.classList.add('dark-mode');
            } else {
                document.body.classList.remove('dark-mode');
            }
            
            // Toggle dark mode on click
            darkModeToggle.onclick = () => {
                const isCurrentlyDark = document.body.classList.contains('dark-mode');
                
                if (isCurrentlyDark) {
                    document.body.classList.remove('dark-mode');
                    localStorage.setItem('darkMode', 'false');
                } else {
                    document.body.classList.add('dark-mode');
                    localStorage.setItem('darkMode', 'true');
                }
            };
        }
        
        // Disabled: "-" key for alt style toggle (development guide)
        // function initAltStyleToggle() {
        //     document.addEventListener('keydown', function(e) {
        //         // Check if "-" key is pressed (not in input fields)
        //         if (e.key === '-' && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
        //             document.body.classList.toggle('alt-style');
        //         }
        //     });
        // }
        
        // Info Overlay Toggle
        function initInfoOverlay() {
            const brandSvgs = document.getElementById('brandSvgs');
            const infoOverlay = document.getElementById('infoOverlay');
            
            if (!brandSvgs || !infoOverlay) return;
            
            let touchStartY = 0;
            let touchCurrentY = 0;
            let isSwiping = false;
            let startScrollTop = 0;
            
            // SVG hover state tracking
            let isHovered = false;
            let isModalOpen = false;
            
            // Change SVGs on hover: 1→5, 2→6, 3→3, 4→2 with sliding animation
            const svgWrappers = brandSvgs.querySelectorAll('.brand-svg-wrapper');
            const originalSrcs = ['SVG/ooft/1.svg', 'SVG/ooft/2.svg', 'SVG/ooft/3.svg', 'SVG/ooft/4.svg'];
            const hoverSrcs = ['SVG/ooft/5.svg', 'SVG/ooft/6.svg', 'SVG/ooft/3.svg', 'SVG/ooft/2.svg'];
            
            function animateToHover() {
                if (isHovered) return;
                isHovered = true;
                
                const imgs = Array.from(svgWrappers).map(w => w.querySelector('.brand-svg'));
                
                // All animations happen simultaneously - same timing for all
                const fadeDelay = 80; // Fast fade timing
                
                // Position 1: 1 fades out, 5 fades in
                if (imgs[0]) {
                    imgs[0].style.opacity = '0';
                    setTimeout(() => {
                        imgs[0].src = hoverSrcs[0]; // 5
                        imgs[0].style.opacity = '1';
                    }, fadeDelay);
                }
                
                // Position 2: 2 slides right while fading out, 6 fades in (simultaneous)
                if (imgs[1]) {
                    imgs[1].style.transform = 'translateX(200%)';
                    imgs[1].style.opacity = '0';
                    setTimeout(() => {
                        imgs[1].src = hoverSrcs[1]; // 6
                        imgs[1].style.transform = 'translateX(0)';
                        imgs[1].style.opacity = '1';
                    }, fadeDelay);
                }
                
                // Position 3: 3 stays (no change)
                if (imgs[2]) {
                    imgs[2].style.transform = 'translateX(0)';
                    imgs[2].style.opacity = '1';
                }
                
                // Position 4: 4 fades out, 2 fades in (simultaneous)
                if (imgs[3]) {
                    imgs[3].style.opacity = '0';
                    setTimeout(() => {
                        imgs[3].src = hoverSrcs[3]; // 2
                        imgs[3].style.transform = 'translateX(0)';
                        imgs[3].style.opacity = '1';
                    }, fadeDelay);
                }
            }
            
            function animateToOriginal() {
                // Don't revert if modal is open
                if (isModalOpen) return;
                
                if (!isHovered) return;
                isHovered = false;
                
                const imgs = Array.from(svgWrappers).map(w => w.querySelector('.brand-svg'));
                
                // All animations happen simultaneously in reverse - same timing for all
                const fadeDelay = 80; // Fast fade timing
                
                // Position 1: 5 fades out, 1 fades in (reverse)
                if (imgs[0]) {
                    imgs[0].style.opacity = '0';
                    setTimeout(() => {
                        imgs[0].src = originalSrcs[0]; // 1
                        imgs[0].style.opacity = '1';
                    }, fadeDelay);
                }
                
                // Position 2: 6 slides right while fading out, 2 fades in (reverse)
                if (imgs[1]) {
                    imgs[1].style.transform = 'translateX(200%)';
                    imgs[1].style.opacity = '0';
                    setTimeout(() => {
                        imgs[1].src = originalSrcs[1]; // 2
                        imgs[1].style.transform = 'translateX(0)';
                        imgs[1].style.opacity = '1';
                    }, fadeDelay);
                }
                
                // Position 3: 3 stays (no change)
                if (imgs[2]) {
                    imgs[2].style.transform = 'translateX(0)';
                    imgs[2].style.opacity = '1';
                }
                
                // Position 4: 2 fades out, 4 fades in (reverse)
                if (imgs[3]) {
                    imgs[3].style.opacity = '0';
                    setTimeout(() => {
                        imgs[3].src = originalSrcs[3]; // 4
                        imgs[3].style.transform = 'translateX(0)';
                        imgs[3].style.opacity = '1';
                    }, fadeDelay);
                }
            }
            
            function showOverlay() {
                // Save and lock body scroll position
                const scrollY = window.scrollY;
                document.body.style.position = 'fixed';
                document.body.style.top = `-${scrollY}px`;
                document.body.style.width = '100%';
                document.body.dataset.scrollY = scrollY;
                
                infoOverlay.classList.add('active');
                document.body.classList.add('info-overlay-open');
                document.body.style.overflow = 'hidden';
                
                // Keep hover state when modal opens
                isModalOpen = true;
                if (!isHovered) {
                    // If not hovered, trigger hover state
                    animateToHover();
                }
                
                // Disable scrolling on all background elements
                const pageWrapper = document.querySelector('.page-wrapper');
                const gridSection = document.querySelector('.grid-section');
                const html = document.documentElement;
                
                if (pageWrapper) {
                    pageWrapper.style.overflow = 'hidden';
                }
                if (gridSection) {
                    gridSection.style.overflow = 'hidden';
                }
                html.style.overflow = 'hidden';
                
                // Reset displacement tracking
                currentDisplacement = 0;
                isAutoCompleting = false;
                infoOverlay.style.transform = 'translateY(0)';
                infoOverlay.style.opacity = '1';
                infoOverlay.style.transition = '';
            }
            
            // Helper function for auto-completion
            function autoCompleteSlide(direction) {
                if (isAutoCompleting) return; // Prevent multiple calls
                isAutoCompleting = true;
                infoOverlay.style.transition = 'transform 0.35s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.35s cubic-bezier(0.4, 0, 0.2, 1)';
                if (direction === 'down') {
                    infoOverlay.style.transform = 'translateY(100vh)';
                } else {
                    infoOverlay.style.transform = 'translateY(-100vh)';
                }
                infoOverlay.style.opacity = '0';
                hideOverlay();
            }
            
            function hideOverlay() {
                // Don't remove active class immediately - wait for animation
                // The transform is already set by the caller
                // Keep scroll locked until animation completes
                const scrollY = document.body.dataset.scrollY || 0;
                
                // Wait for animation to complete (350ms) before cleaning up and re-enabling scroll
                setTimeout(() => {
                    infoOverlay.classList.remove('active');
                    infoOverlay.style.transform = '';
                    infoOverlay.style.opacity = '';
                    infoOverlay.style.transition = '';
                    document.body.classList.remove('info-overlay-open');
                    document.body.style.position = '';
                    document.body.style.top = '';
                    document.body.style.width = '';
                    document.body.style.overflow = '';
                    window.scrollTo(0, parseInt(scrollY) || 0);
                    delete document.body.dataset.scrollY;
                    
                    // Re-enable scrolling on background elements AFTER animation completes
                    const pageWrapper = document.querySelector('.page-wrapper');
                    const gridSection = document.querySelector('.grid-section');
                    const html = document.documentElement;
                    
                    if (pageWrapper) {
                        pageWrapper.style.overflow = '';
                    }
                    if (gridSection) {
                        gridSection.style.overflow = '';
                    }
                    html.style.overflow = '';
                    
                    // Revert SVGs to original state when modal closes
                    isModalOpen = false;
                    if (isHovered) {
                        animateToOriginal();
                    }
                }, 350);
            }
            
            brandSvgs.addEventListener('mouseenter', function() {
                // Reset rotation BEFORE blocking and animating
                if (window.brandSvgRotation && window.brandSvgRotation.reset) {
                    window.brandSvgRotation.reset();
                }
                window.isHoveringBrandSvgs = true; // Block rotation
                animateToHover();
            });
            brandSvgs.addEventListener('mouseleave', function() {
                window.isHoveringBrandSvgs = false; // Resume rotation
                animateToOriginal();
            });
            
            // Toggle overlay when clicking brand SVGs
            brandSvgs.addEventListener('click', function(e) {
                e.stopPropagation();
                // If overlay is already open, close it; otherwise open it
                if (infoOverlay.classList.contains('active')) {
                    // Slide up and out of view with fade
                    infoOverlay.style.transition = 'transform 0.35s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.35s cubic-bezier(0.4, 0, 0.2, 1)';
                    infoOverlay.style.transform = 'translateY(-100vh)';
                    infoOverlay.style.opacity = '0';
                    hideOverlay();
                } else {
                    showOverlay();
                }
            });
            
            // Hide overlay when clicking background - slide up and out with fade
            infoOverlay.addEventListener('click', function(e) {
                if (e.target === infoOverlay) {
                    // Slide up and out of view with fade
                    infoOverlay.style.transition = 'transform 0.35s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.35s cubic-bezier(0.4, 0, 0.2, 1)';
                    infoOverlay.style.transform = 'translateY(-100vh)';
                    infoOverlay.style.opacity = '0';
                    hideOverlay();
                }
            });
            
            // Hide overlay on Escape key - slide up and out with fade
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && infoOverlay.classList.contains('active')) {
                    // Slide up and out of view with fade
                    infoOverlay.style.transition = 'transform 0.35s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.35s cubic-bezier(0.4, 0, 0.2, 1)';
                    infoOverlay.style.transform = 'translateY(-100vh)';
                    infoOverlay.style.opacity = '0';
                    hideOverlay();
                }
            });
            
            
            // Simple scroll-based closing - works like normal website scrolling
            let isDragging = false;
            let dragStartY = 0;
            let dragCurrentY = 0;
            
            // Displacement tracking for connected scroll control
            let currentDisplacement = 0;
            const THRESHOLD = 150; // Small threshold (150px) for control before auto-complete
            let isAutoCompleting = false;
            
            // Wheel/scroll events - REVERSED: scroll direction matches modal movement
            infoOverlay.addEventListener('wheel', function(e) {
                if (isAutoCompleting) return; // Ignore if already auto-completing
                
                const scrollTop = infoOverlay.scrollTop;
                const scrollHeight = infoOverlay.scrollHeight;
                const clientHeight = infoOverlay.clientHeight;
                const isScrollable = scrollHeight > clientHeight;
                const isAtTop = scrollTop <= 5;
                const isAtBottom = scrollTop + clientHeight >= scrollHeight - 5;
                
                // REVERSED: Swipe UP (e.deltaY < 0) → modal slides UP
                if ((!isScrollable || isAtTop) && e.deltaY < 0) {
                    e.preventDefault();
                    infoOverlay.style.transition = 'none';
                    currentDisplacement += e.deltaY; // deltaY is negative
                    
                    if (currentDisplacement <= -THRESHOLD) {
                        currentDisplacement = 0;
                        autoCompleteSlide('up'); // translateY(-100vh) = slides UP
                    } else {
                        // Calculate opacity based on displacement (fade out as it moves)
                        const opacity = Math.max(0, 1 + (currentDisplacement / THRESHOLD));
                        infoOverlay.style.transform = `translateY(${currentDisplacement}px)`;
                        infoOverlay.style.opacity = opacity;
                    }
                }
                // REVERSED: Swipe DOWN (e.deltaY > 0) → modal slides DOWN  
                else if ((!isScrollable || isAtBottom) && e.deltaY > 0) {
                    e.preventDefault();
                    infoOverlay.style.transition = 'none';
                    currentDisplacement += e.deltaY; // deltaY is positive
                    
                    if (currentDisplacement >= THRESHOLD) {
                        currentDisplacement = 0;
                        autoCompleteSlide('down'); // translateY(100vh) = slides DOWN
                    } else {
                        // Calculate opacity based on displacement (fade out as it moves)
                        const opacity = Math.max(0, 1 - (currentDisplacement / THRESHOLD));
                        infoOverlay.style.transform = `translateY(${currentDisplacement}px)`;
                        infoOverlay.style.opacity = opacity;
                    }
                }
                // Reduce displacement if scrolling opposite direction
                else if ((!isScrollable || isAtTop) && e.deltaY > 0 && currentDisplacement < 0) {
                    e.preventDefault();
                    infoOverlay.style.transition = 'none';
                    currentDisplacement += e.deltaY;
                    currentDisplacement = Math.min(0, currentDisplacement);
                    // Calculate opacity based on displacement (fade back in)
                    const opacity = Math.max(0, 1 + (currentDisplacement / THRESHOLD));
                    infoOverlay.style.transform = `translateY(${currentDisplacement}px)`;
                    infoOverlay.style.opacity = opacity;
                }
                else if ((!isScrollable || isAtBottom) && e.deltaY < 0 && currentDisplacement > 0) {
                    e.preventDefault();
                    infoOverlay.style.transition = 'none';
                    currentDisplacement += e.deltaY;
                    currentDisplacement = Math.max(0, currentDisplacement);
                    // Calculate opacity based on displacement (fade back in)
                    const opacity = Math.max(0, 1 - (currentDisplacement / THRESHOLD));
                    infoOverlay.style.transform = `translateY(${currentDisplacement}px)`;
                    infoOverlay.style.opacity = opacity;
                }
            }, { passive: false });
            
            // Touch events - connected drag to close
            infoOverlay.addEventListener('touchstart', function(e) {
                if (isAutoCompleting) return;
                
                const scrollTop = infoOverlay.scrollTop;
                const scrollHeight = infoOverlay.scrollHeight;
                const clientHeight = infoOverlay.clientHeight;
                const isAtTop = scrollTop === 0;
                const isAtBottom = scrollTop + clientHeight >= scrollHeight - 1;
                
                // Only allow drag if at top or bottom
                if (isAtTop || isAtBottom) {
                    isDragging = true;
                    dragStartY = e.touches[0].clientY;
                    dragCurrentY = dragStartY;
                    infoOverlay.style.transition = 'none';
                    // Reset displacement when starting new drag
                    currentDisplacement = 0;
                }
            }, { passive: true });
            
            infoOverlay.addEventListener('touchmove', function(e) {
                if (!isDragging || isAutoCompleting) return;
                
                dragCurrentY = e.touches[0].clientY;
                const deltaY = dragCurrentY - dragStartY;
                const scrollTop = infoOverlay.scrollTop;
                const scrollHeight = infoOverlay.scrollHeight;
                const clientHeight = infoOverlay.clientHeight;
                const isAtTop = scrollTop === 0;
                const isAtBottom = scrollTop + clientHeight >= scrollHeight - 1;
                
                // REVERSED: Check if content scrolled - cancel drag if so
                if ((isAtTop && deltaY > 0) || (isAtBottom && deltaY < 0)) {
                    // Content is scrolling, cancel drag
                    isDragging = false;
                    currentDisplacement = 0;
                    infoOverlay.style.transform = 'translateY(0)';
                    infoOverlay.style.opacity = '1';
                    infoOverlay.style.transition = '';
                    return;
                }
                
                // Prevent default to allow overlay movement
                e.preventDefault();
                
                // Update current displacement
                currentDisplacement = deltaY;
                
                // REVERSED: Move overlay with finger - apply directly but check threshold
                if (isAtTop && deltaY < 0) {
                    // Dragging UP from top - slide up
                    if (deltaY <= -THRESHOLD) {
                        // Auto-complete slide up
                        autoCompleteSlide('up');
                    } else {
                        // Apply displacement directly (clamped to threshold) with fade
                        const clampedDelta = Math.max(deltaY, -THRESHOLD);
                        const opacity = Math.max(0, 1 + (clampedDelta / THRESHOLD));
                        infoOverlay.style.transform = `translateY(${clampedDelta}px)`;
                        infoOverlay.style.opacity = opacity;
                    }
                } else if (isAtBottom && deltaY > 0) {
                    // Dragging DOWN from bottom - slide down
                    if (deltaY >= THRESHOLD) {
                        // Auto-complete slide down
                        autoCompleteSlide('down');
                    } else {
                        // Apply displacement directly (clamped to threshold) with fade
                        const clampedDelta = Math.min(deltaY, THRESHOLD);
                        const opacity = Math.max(0, 1 - (clampedDelta / THRESHOLD));
                        infoOverlay.style.transform = `translateY(${clampedDelta}px)`;
                        infoOverlay.style.opacity = opacity;
                    }
                }
            }, { passive: false });
            
            infoOverlay.addEventListener('touchend', function(e) {
                if (!isDragging) return;
                isDragging = false;
                
                if (isAutoCompleting) return; // Already auto-completing
                
                const scrollTop = infoOverlay.scrollTop;
                const scrollHeight = infoOverlay.scrollHeight;
                const clientHeight = infoOverlay.clientHeight;
                const isAtTop = scrollTop === 0;
                const isAtBottom = scrollTop + clientHeight >= scrollHeight - 1;
                
                const endY = e.changedTouches[0].clientY;
                const deltaY = endY - dragStartY;
                
                infoOverlay.style.transition = 'transform 0.35s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.35s cubic-bezier(0.4, 0, 0.2, 1)';
                
                // REVERSED: Check if reached threshold for auto-completion
                if (isAtTop && Math.abs(deltaY) >= THRESHOLD && deltaY < 0) {
                    // Dragged up from top - auto-complete slide up
                    autoCompleteSlide('up');
                } else if (isAtBottom && Math.abs(deltaY) >= THRESHOLD && deltaY > 0) {
                    // Dragged down from bottom - auto-complete slide down
                    autoCompleteSlide('down');
                } else {
                    // Snap back if below threshold (fade back in)
                    currentDisplacement = 0;
                    infoOverlay.style.transform = 'translateY(0)';
                    infoOverlay.style.opacity = '1';
                }
            }, { passive: true });
            
        }
        
        // Global flag to track if mouse is hovering over brand SVGs - blocks rotation
        window.isHoveringBrandSvgs = false;
        
        // Global rotation state to allow reset on hover
        window.brandSvgRotation = {
            svg1: null,
            svg2: null,
            rotation1: 0,
            rotation2: 0,
            reset: function() {
                this.rotation1 = 0;
                this.rotation2 = 0;
                if (this.svg1) {
                    // Remove rotation from transform, preserve other transforms
                    const currentTransform = this.svg1.style.transform || '';
                    const cleanTransform = currentTransform.replace(/rotate\([^)]+\)\s*/g, '').trim();
                    this.svg1.style.transform = cleanTransform || '';
                }
                if (this.svg2) {
                    // Remove rotation from transform, preserve other transforms
                    const currentTransform = this.svg2.style.transform || '';
                    const cleanTransform = currentTransform.replace(/rotate\([^)]+\)\s*/g, '').trim();
                    this.svg2.style.transform = cleanTransform || '';
                }
            }
        };
        
        // Brand SVG scroll rotation (1 and 2 SVGs)
        function initBrandScrollRotation() {
            const svgWrappers = document.querySelectorAll('.brand-svg-wrapper');
            const svg1 = svgWrappers[0]?.querySelector('.brand-svg');
            const svg2 = svgWrappers[1]?.querySelector('.brand-svg');
            
            if (!svg1 || !svg2) return;
            
            // Store references globally
            window.brandSvgRotation.svg1 = svg1;
            window.brandSvgRotation.svg2 = svg2;
            
            let rotation1 = 0;
            let rotation2 = 0;
            let lastScrollY = window.scrollY;
            let ticking = false;
            
            function updateRotation() {
                // BLOCK ROTATION when hovering over brand SVGs
                if (window.isHoveringBrandSvgs) {
                    lastScrollY = window.scrollY;
                    ticking = false;
                    return; // Skip rotation completely when hovering
                }
                
                const currentScrollY = window.scrollY;
                const scrollDelta = currentScrollY - lastScrollY;
                
                // Rotate based on scroll direction and speed
                // Scroll down (positive delta) = rotate right (positive degrees)
                // Scroll up (negative delta) = rotate left (negative degrees)
                const rotationSpeed = scrollDelta * 0.5; // Adjust multiplier for rotation sensitivity
                
                rotation1 += rotationSpeed;
                rotation2 += rotationSpeed;
                
                // Store rotation values globally
                window.brandSvgRotation.rotation1 = rotation1;
                window.brandSvgRotation.rotation2 = rotation2;
                
                // Apply rotation
                svg1.style.transform = `rotate(${rotation1}deg)`;
                svg2.style.transform = `rotate(${rotation2}deg)`;
                
                lastScrollY = currentScrollY;
                ticking = false;
            }
            
            window.addEventListener('scroll', function() {
                if (!ticking) {
                    window.requestAnimationFrame(updateRotation);
                    ticking = true;
                }
            }, { passive: true });
        }

        
        // Wait for DOM to be ready, then load portfolio
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize grid columns based on screen size and saved preference
            limits = getColumnLimits();
            
            // Check for saved grid columns preference
            const savedColumns = localStorage.getItem('gridColumns');
            // Default to max zoom (max columns) on first load
            let initialColumns = limits.max;
            
            // Only use saved preference if it exists (user has changed it before)
            if (savedColumns) {
                const savedCols = parseInt(savedColumns);
                // Only use saved value if it's within current limits
                if (savedCols >= limits.min && savedCols <= limits.max) {
                    initialColumns = savedCols;
                }
            }
            
            // Set initial columns (this will update CSS variable and render)
            currentColumns = initialColumns;
            document.documentElement.style.setProperty('--grid-columns', initialColumns);
            
            // Update UI elements
            const sizeSlider = document.getElementById('sizeSlider');
            const columnCount = document.getElementById('columnCount');
            const gridColumnCounter = document.getElementById('gridColumnCounter');
            
            if (sizeSlider) {
                sizeSlider.min = limits.min;
                sizeSlider.max = limits.max;
                sizeSlider.value = initialColumns;
            }
            if (columnCount) columnCount.textContent = initialColumns;
            if (gridColumnCounter) gridColumnCounter.textContent = initialColumns;
            
            // Load portfolio data and render placeholders immediately (before search animation)
            loadPortfolioPlaceholders();
            initDarkModeToggle();
            initSearchBar();
            // Disabled: initAltStyleToggle() - development guide
            // initAltStyleToggle();
            initBrandScrollRotation();
            initInfoOverlay();
            // setupFilters(); // Function not defined, commented out
            
            // Listen for hash changes (e.g., browser back/forward buttons)
            window.addEventListener('hashchange', function() {
                checkURLHash();
            });
            
            // Static logo overlay with blur and click-to-dismiss
            // Show on main grid page every time (grid or lightbox), but NOT on info overlay
            // Apply blur IMMEDIATELY on page load, before grid renders
            const brandSvgsStatic = document.getElementById('brandSvgsStatic');
            const hasHash = window.location.hash && window.location.hash.length > 1;
            
            // Check if this is a reload
            const isReload = document.body.getAttribute('data-is-reload') === 'true';
            
            // Inactivity (screensaver) settings
            const inactivityDelayMs = 8000;
            let inactivityTimer = null;
            
            const coverState = {
                interactionsEnabled: false,
                logoDismissed: false,
                listenersAttached: false,
                scrollPreventers: []
            };
            
            // Prevent all scroll events when cover is visible
            function preventScroll(e) {
                // Only prevent if cover is actually visible
                if (document.body && document.body.classList.contains('brand-logo-visible') && 
                    brandSvgsStatic && !brandSvgsStatic.classList.contains('dismissed')) {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
            }
            
            function addScrollPreventers() {
                if (coverState.scrollPreventers.length > 0) return; // Already added
                
                const preventers = [
                    { element: window, events: ['scroll', 'wheel', 'touchmove'], handler: preventScroll },
                    { element: document, events: ['scroll', 'wheel', 'touchmove'], handler: preventScroll },
                    { element: document.body, events: ['scroll', 'wheel', 'touchmove'], handler: preventScroll }
                ];
                
                preventers.forEach(({ element, events, handler }) => {
                    events.forEach(eventType => {
                        element.addEventListener(eventType, handler, { passive: false, capture: true });
                        coverState.scrollPreventers.push({ element, eventType, handler });
                    });
                });
            }
            
            function removeScrollPreventers() {
                coverState.scrollPreventers.forEach(({ element, eventType, handler }) => {
                    element.removeEventListener(eventType, handler, { capture: true });
                });
                coverState.scrollPreventers = [];
            }
            
            function applyBlurAndShowLogo() {
                document.body.classList.add('brand-logo-visible');
                document.documentElement.classList.add('brand-logo-visible');
                // Disable scrolling when cover is visible
                document.body.style.overflow = 'hidden';
                document.documentElement.style.overflow = 'hidden';
                // Prevent all scroll events
                addScrollPreventers();
                if (brandSvgsStatic) {
                    brandSvgsStatic.classList.remove('dismissed');
                    brandSvgsStatic.style.opacity = '1';
                }
            }
            
            function dismissLogo() {
                if (!brandSvgsStatic) return;
                if (coverState.logoDismissed) return;
                coverState.logoDismissed = true;
                brandSvgsStatic.classList.add('dismissed');
                document.body.classList.remove('brand-logo-visible');
                document.documentElement.classList.remove('brand-logo-visible');
                // Re-enable scrolling when cover is dismissed
                document.body.style.overflow = '';
                document.documentElement.style.overflow = '';
                document.body.style.pointerEvents = '';
                // Remove scroll preventers
                removeScrollPreventers();
                resetInactivityTimer();
            }
            
            function attachCoverListeners() {
                if (!brandSvgsStatic || coverState.listenersAttached) return;
                coverState.listenersAttached = true;
                
                function handleDismiss(e) {
                    if (coverState.interactionsEnabled && !coverState.logoDismissed) {
                        dismissLogo();
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }
                
                brandSvgsStatic.addEventListener('click', handleDismiss);
                document.addEventListener('click', handleDismiss, true);
                
                let scrollTimeout;
                function handleScroll() {
                    if (coverState.interactionsEnabled && !coverState.logoDismissed) {
                        clearTimeout(scrollTimeout);
                        scrollTimeout = setTimeout(() => {
                            dismissLogo();
                        }, 50);
                    }
                }
                
                window.addEventListener('scroll', handleScroll, { passive: true });
                window.addEventListener('wheel', handleScroll, { passive: true });
                
                // Mouse move to dismiss (after interactions enabled)
                function handleMouseMove() {
                    if (coverState.interactionsEnabled && !coverState.logoDismissed) {
                        dismissLogo();
                    }
                }
                
                document.addEventListener('mousemove', handleMouseMove, { passive: true });
                
                let touchStartY = 0;
                let touchStartX = 0;
                
                function handleTouchStart(e) {
                    if (coverState.interactionsEnabled && !coverState.logoDismissed) {
                        touchStartY = e.touches[0].clientY;
                        touchStartX = e.touches[0].clientX;
                    }
                }
                
                function handleTouchMove(e) {
                    if (coverState.interactionsEnabled && !coverState.logoDismissed) {
                        const touchEndY = e.touches[0].clientY;
                        const touchEndX = e.touches[0].clientX;
                        const deltaY = Math.abs(touchEndY - touchStartY);
                        const deltaX = Math.abs(touchEndX - touchStartX);
                        
                        if (deltaY > 10 || deltaX > 10) {
                            dismissLogo();
                        }
                    }
                }
                
                document.addEventListener('touchstart', handleTouchStart, { passive: true });
                document.addEventListener('touchmove', handleTouchMove, { passive: true });
            }
            
            function isLightboxOpen() {
                const lightbox = document.getElementById('lightbox');
                return lightbox && lightbox.classList.contains('active');
            }
            
            function showCover({ delayInteractionsMs = 0 } = {}) {
                if (!brandSvgsStatic) return;
                if (document.body.classList.contains('info-overlay-open')) return; // don't show on info page
                if (isLightboxOpen()) return; // NEVER show when lightbox is open
                
                coverState.logoDismissed = false;
                coverState.interactionsEnabled = delayInteractionsMs === 0;
                
                applyBlurAndShowLogo();
                attachCoverListeners();
                
                if (delayInteractionsMs > 0) {
                    document.body.style.pointerEvents = 'none';
                    brandSvgsStatic.style.pointerEvents = 'auto';
                    setTimeout(() => {
                        coverState.interactionsEnabled = true;
                        document.body.style.pointerEvents = '';
                    }, delayInteractionsMs);
                } else {
                    document.body.style.pointerEvents = '';
                    coverState.interactionsEnabled = true;
                }
            }
            
            function resetInactivityTimer() {
                clearTimeout(inactivityTimer);
                if (document.body.classList.contains('info-overlay-open')) {
                    return;
                }
                if (isLightboxOpen()) {
                    return; // NEVER start timer when lightbox is open
                }
                inactivityTimer = setTimeout(() => {
                    if (document.body.classList.contains('info-overlay-open')) return;
                    if (isLightboxOpen()) return; // Double check before showing
                    showCover({ delayInteractionsMs: 0 }); // screensaver style: immediate interactions
                }, inactivityDelayMs);
            }
            
            // Always show website immediately if hash exists (lightbox)
            if (hasHash) {
                document.body.classList.add('website-loaded');
            } else {
                // On reload: show website instantly; on first load: wait 0.5s
                if (isReload) {
                    document.body.classList.add('website-loaded');
                } else {
                    setTimeout(() => {
                        document.body.classList.add('website-loaded');
                    }, 500);
                }
            }
            
            // Then check after a short delay if we should show the cover
            setTimeout(() => {
                // If we're in lightbox (hash present) on load, never show cover immediately.
                // Cover can still appear later via inactivity timer.
                if (hasHash) {
                    resetInactivityTimer();
                    return;
                }
                
                if (document.body.classList.contains('info-overlay-open')) {
                    resetInactivityTimer();
                    return;
                }
                
                // Wait a bit to allow navigation to settle, then show cover on grid
                setTimeout(() => {
                    if (brandSvgsStatic) {
                        showCover({ delayInteractionsMs: isReload ? 0 : 2000 });
                    }
                }, 500);
            }, 100);
            
            // Inactivity (screensaver) - show cover after 8s of no activity (unless on info page or lightbox)
            ['mousemove', 'mousedown', 'keydown', 'scroll', 'wheel', 'touchstart', 'touchmove'].forEach(evt => {
                document.addEventListener(evt, resetInactivityTimer, { passive: true });
            });
            
            // Watch for lightbox state changes - clear timer when lightbox opens, dismiss cover if showing
            const lightbox = document.getElementById('lightbox');
            if (lightbox) {
                const observer = new MutationObserver(() => {
                    if (isLightboxOpen()) {
                        clearTimeout(inactivityTimer);
                        // Dismiss cover if it's showing when lightbox opens
                        if (brandSvgsStatic && !brandSvgsStatic.classList.contains('dismissed')) {
                            dismissLogo();
                        }
                    } else {
                        // Lightbox closed - restart timer
                        resetInactivityTimer();
                    }
                });
                observer.observe(lightbox, { attributes: true, attributeFilter: ['class'] });
            }
            
            resetInactivityTimer();
        });
        
        
        // ooft.studio static SVG rendering
        function initOoftStudioAnimation() {
            const brandButton = document.getElementById('ooftStudioBrand');
            if (!brandButton) return;
            
            const brandContentElement = brandButton.querySelector('.btn__brand-content');
            if (!brandContentElement) return;
            
            // Only render SVGs - 1, 2, 3, 4 from "ooft"
            const svgs = [
                'SVG/ooft/1.svg',
                'SVG/ooft/2.svg',
                'SVG/ooft/3.svg',
                'SVG/ooft/4.svg'
            ];
            
            // Render only the SVG files
            svgs.forEach(svgPath => {
                const element = document.createElement('img');
                element.src = svgPath;
                element.alt = '';
                brandContentElement.appendChild(element);
            });
        }
        
        // Search bar functionality
        let searchTerms = []; // Will be populated with real tags from JSON
        let currentTermIndex = 0;
        let animationInterval;
        let typewriterTimeout;
        let isInitialSequence = false;
        
        // Extract unique tags from portfolio data and randomize them
        function updateSearchTermsFromCSV() {
            if (!portfolioData || portfolioData.length === 0) return;
            
            const allTags = new Set();
            
            // Extract all tags from portfolio data
            portfolioData.forEach(item => {
                if (item.tags && item.tags.length > 0) {
                    item.tags.forEach(tag => {
                        const trimmedTag = tag.trim().toLowerCase();
                        if (trimmedTag && trimmedTag.length > 0) {
                            allTags.add(trimmedTag);
                        }
                    });
                }
            });
            
            // Convert to array and randomize
            searchTerms = Array.from(allTags);
            
            // Shuffle array (Fisher-Yates algorithm)
            for (let i = searchTerms.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [searchTerms[i], searchTerms[j]] = [searchTerms[j], searchTerms[i]];
            }
            
            // If we have search terms, update the animated text
            if (searchTerms.length > 0) {
                const animatedText = document.getElementById('animatedSearchText');
                if (animatedText) {
                    const span = animatedText.querySelector('span');
                    if (span) {
                        span.textContent = searchTerms[0];
                    }
                }
            }
        }
        
        function initSearchBar() {
            const searchInput = document.getElementById('searchInput');
            const searchClose = document.getElementById('searchClose');
            const searchBar = document.getElementById('searchBar');
            const animatedText = document.getElementById('animatedSearchText');
            
            if (!searchInput || !searchClose) return;
            
            // If portfolio data is already loaded, extract tags
            if (portfolioData && portfolioData.length > 0) {
                updateSearchTermsFromCSV();
            }
            
            // Fallback to default terms if no tags found
            if (searchTerms.length === 0) {
                searchTerms = [
                    'client',
                    'advertising',
                    'design',
                    'brand creation',
                    'art',
                    'typography',
                    'film',
                    'experiments'
                ];
            }
            
            // Typewriter effect function
            function typewriterEffect(text, callback, speed = 50) {
                if (!animatedText) return;
                let index = 0;
                const span = animatedText.querySelector('span') || document.createElement('span');
                span.textContent = '';
                animatedText.innerHTML = '';
                animatedText.appendChild(span);
                
                function type() {
                    if (index < text.length) {
                        span.textContent += text[index];
                        index++;
                        typewriterTimeout = setTimeout(type, speed);
                    } else if (callback) {
                        callback();
                    }
                }
                type();
            }
            
            // Untype effect function
            function untypeEffect(callback, speed = 30) {
                if (!animatedText) return;
                const span = animatedText.querySelector('span');
                if (!span) {
                    if (callback) callback();
                    return;
                }
                
                function untype() {
                    if (span.textContent.length > 0) {
                        span.textContent = span.textContent.slice(0, -1);
                        typewriterTimeout = setTimeout(untype, speed);
                    } else if (callback) {
                        callback();
                    }
                }
                untype();
            }
            
            // Function to update animated text (scroll animation)
            function updateAnimatedText() {
                if (!animatedText) return;
                
                // Ensure we have search terms
                if (searchTerms.length === 0) return;
                
                // Only animate if input is not focused and empty
                if (document.activeElement !== searchInput && !searchInput.value.trim()) {
                    const oldSpan = animatedText.querySelector('span');
                    
                    // Animate old text out (scroll up)
                    if (oldSpan) {
                        oldSpan.classList.add('scrolling-out');
                    }
                    
                    // After a short delay, add new text (scroll up from bottom)
                    setTimeout(() => {
                        currentTermIndex = (currentTermIndex + 1) % searchTerms.length;
                        const newTerm = searchTerms[currentTermIndex];
                        
                        // Create new span with animation
                        const newSpan = document.createElement('span');
                        newSpan.textContent = newTerm;
                        animatedText.innerHTML = '';
                        animatedText.appendChild(newSpan);
                    }, 150); // Half of animation duration for smooth transition
                }
            }
            
            // Start animation cycle (scroll animation)
            function startAnimation() {
                if (animationInterval) clearInterval(animationInterval);
                animationInterval = setInterval(updateAnimatedText, 625); // Change every 0.625 seconds (slowed by 25%)
            }
            
            // Stop animation when input is focused or has value
            function stopAnimation() {
                if (animationInterval) {
                    clearInterval(animationInterval);
                    animationInterval = null;
                }
                if (typewriterTimeout) {
                    clearTimeout(typewriterTimeout);
                    typewriterTimeout = null;
                }
            }
            
            // Initialize search bar - show first search term immediately
            function initSearchBarDisplay() {
                if (!animatedText) return;
                
                // Ensure we have search terms
                if (searchTerms.length === 0) {
                    return;
                }
                
                // Show first search term immediately
                isInitialSequence = false;
                currentTermIndex = 0;
                const newSpan = document.createElement('span');
                newSpan.textContent = searchTerms[0];
                animatedText.innerHTML = '';
                animatedText.appendChild(newSpan);
                
                // Enable lazy loading and start animation cycle
                setupLazyLoading();
                setTimeout(() => {
                    startAnimation();
                }, 2000); // Start cycling after 2 seconds
            }
            
            // Scroll up text animation (replaces current text with new text scrolling up)
            function scrollUpText(newText, callback) {
                if (!animatedText) return;
                const oldSpan = animatedText.querySelector('span');
                
                // Animate old text out (scroll up)
                if (oldSpan) {
                    oldSpan.classList.add('scrolling-out');
                }
                
                // After a short delay, add new text (scroll up from bottom)
                setTimeout(() => {
                    const newSpan = document.createElement('span');
                    newSpan.textContent = newText;
                    animatedText.innerHTML = '';
                    animatedText.appendChild(newSpan);
                    if (callback) {
                        setTimeout(callback, 150);
                    }
                }, 150);
            }
            
            // Initialize search bar display immediately
            initSearchBarDisplay();
            
            // Click on input or search bar - clear and focus
            searchBar.addEventListener('click', (e) => {
                // Don't do anything if clicking the X button itself
                if (e.target === searchClose || searchClose.contains(e.target)) {
                    return;
                }
                
                const lightbox = document.getElementById('lightbox');
                const isLightboxOpen = lightbox && lightbox.classList.contains('active');
                
                // If in lightbox mode, clear the input when clicked
                if (isLightboxOpen && searchInput.value) {
                    searchInput.value = '';
                }
                
                searchInput.focus();
                if (searchInput.value === '' && searchInput.placeholder) {
                    searchInput.placeholder = '';
                }
                // Show X button immediately when clicking
                searchClose.classList.add('visible');
            });
            
            // Focus event - clear placeholder and show X button
            searchInput.addEventListener('focus', () => {
                searchInput.placeholder = '';
                searchClose.classList.add('visible');
                stopAnimation(); // Stop animation when focused
                const inputWrapper = document.querySelector('.search-bar__input-wrapper');
                if (inputWrapper) {
                    inputWrapper.classList.add('hidden');
                }
            });
            
            // Blur event - restore placeholder if empty (but keep X visible if lightbox is open)
            let isResetting = false;
            searchInput.addEventListener('blur', (e) => {
                // Skip blur handling if we're resetting via X button
                if (isResetting) {
                    isResetting = false;
                    return;
                }
                
                const lightbox = document.getElementById('lightbox');
                const isLightboxOpen = lightbox && lightbox.classList.contains('active');
                
                if (searchInput.value.trim() === '' && !isLightboxOpen) {
                    searchInput.placeholder = '';
                    searchClose.classList.remove('visible'); // Returns to 20% opacity
                    const inputWrapper = document.querySelector('.search-bar__input-wrapper');
                    if (inputWrapper) {
                        inputWrapper.classList.remove('hidden');
                    }
                    startAnimation(); // Restart animation when blurred and empty
                }
            });
            
            // Autocomplete functionality
            const searchAutocomplete = document.getElementById('searchAutocomplete');
            
            function updateAutocomplete(query) {
                if (!searchAutocomplete) return;
                
                if (!query || query.trim().length === 0) {
                    searchAutocomplete.textContent = '';
                    return;
                }
                
                const searchTerm = query.toLowerCase();
                let bestMatch = null;
                let bestMatchText = '';
                
                // Collect all unique potential matches
                const allMatches = new Set();
                
                // Search through portfolio data for matches
                for (const item of portfolioData) {
                    const filename = (item.filename || '').toLowerCase();
                    const folder = (item.folder || '').toLowerCase();
                    const projectName = (item.projectName || '').toLowerCase();
                    const tags = (item.tags || []).map(t => t.toLowerCase()); // Keep as array of individual tags
                    const metadata = (item.metadata || '').toLowerCase();
                    
                    // Check individual fields (not tags as joined string)
                    const fields = [filename, folder, projectName, metadata];
                    for (const field of fields) {
                        if (field.startsWith(searchTerm)) {
                            allMatches.add(field);
                        }
                    }
                    
                    // Check individual tags separately
                    for (const tag of tags) {
                        if (tag.startsWith(searchTerm)) {
                            allMatches.add(tag);
                        }
                    }
                }
                
                // Find the best match (shortest completion)
                for (const match of allMatches) {
                    if (match.startsWith(searchTerm)) {
                        const completion = match.substring(searchTerm.length);
                        if (!bestMatch || completion.length < bestMatchText.length) {
                            bestMatch = match;
                            bestMatchText = completion;
                        }
                    }
                }
                
                // Display the autocomplete suggestion
                if (bestMatchText) {
                    searchAutocomplete.textContent = query + bestMatchText;
                } else {
                    searchAutocomplete.textContent = '';
                }
            }
            
            // Show/hide close button and filter grid based on input value
            searchInput.addEventListener('input', () => {
                const query = searchInput.value;
                const queryTrimmed = query.trim();
                const lightbox = document.getElementById('lightbox');
                const isLightboxOpen = lightbox && lightbox.classList.contains('active');
                const isFocused = document.activeElement === searchInput;
                
                // Update autocomplete
                updateAutocomplete(query);
                
                // Stop animation and hide animated text when typing
                const inputWrapper = document.querySelector('.search-bar__input-wrapper');
                if (queryTrimmed.length > 0) {
                    stopAnimation();
                    if (inputWrapper) {
                        inputWrapper.classList.add('hidden');
                    }
                } else {
                    if (inputWrapper && !isFocused && !isLightboxOpen) {
                        inputWrapper.classList.remove('hidden');
                    }
                    if (!isFocused && !isLightboxOpen) {
                        startAnimation();
                    }
                }
                
                // Keep X visible if there's text, lightbox is open, or input is focused
                if (queryTrimmed.length > 0 || isLightboxOpen || isFocused) {
                    searchClose.classList.add('visible');
                    // Don't filter grid when lightbox is open - allow free editing until Enter is pressed
                    if (!isLightboxOpen) {
                        if (queryTrimmed.length > 0) {
                            filterGrid(queryTrimmed);
                        } else {
                            filterGrid('');
                        }
                    }
                } else {
                    // Only hide X if input is not focused and no text
                    searchClose.classList.remove('visible');
                    if (!isLightboxOpen) {
                        filterGrid('');
                    }
                }
            });
            
            // Handle Enter key in lightbox mode - close lightbox and filter grid
            // Also handle Tab/ArrowRight to accept autocomplete
            searchInput.addEventListener('keydown', (e) => {
                // Accept autocomplete with Tab or ArrowRight
                if ((e.key === 'Tab' || e.key === 'ArrowRight') && searchAutocomplete && searchAutocomplete.textContent) {
                    const currentValue = searchInput.value;
                    const autocompleteText = searchAutocomplete.textContent;
                    if (autocompleteText.startsWith(currentValue)) {
                        e.preventDefault();
                        searchInput.value = autocompleteText;
                        updateAutocomplete(autocompleteText);
                        filterGrid(autocompleteText);
                    }
                    return;
                }
                
                if (e.key === 'Enter' || e.keyCode === 13) {
                    e.preventDefault();
                    const lightbox = document.getElementById('lightbox');
                    const isLightboxOpen = lightbox && lightbox.classList.contains('active');
                    
                    // Use autocomplete suggestion if available, otherwise use typed value
                    let query = searchInput.value.trim();
                    if (searchAutocomplete && searchAutocomplete.textContent) {
                        const autocompleteText = searchAutocomplete.textContent.trim();
                        if (autocompleteText.startsWith(query)) {
                            query = autocompleteText;
                            searchInput.value = query;
                            updateAutocomplete(query);
                        }
                    }
                    
                    if (isLightboxOpen) {
                        // Close lightbox
                        closeLightboxKeepFilter();
                        // Filter grid with the search query (now using complete suggestion if available)
                        if (query.length > 0) {
                            filterGrid(query);
                        } else {
                            filterGrid('');
                        }
                        // Remove focus from input
                        searchInput.blur();
                    } else {
                        // Filter grid with the complete query
                        if (query.length > 0) {
                            filterGrid(query);
                        } else {
                            filterGrid('');
                        }
                    }
                }
            });
            
            // Close button - reset search to default state and close lightbox if open
            searchClose.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                const lightbox = document.getElementById('lightbox');
                
                // Set flag to prevent blur handler from interfering
                isResetting = true;
                
                // If lightbox is open, close it first
                if (lightbox && lightbox.classList.contains('active')) {
                    closeLightboxKeepFilter();
                }
                
                // Reset search to default state (like before it was ever clicked)
                searchInput.value = '';
                searchInput.placeholder = '';
                searchClose.classList.remove('visible'); // Returns to 20% opacity
                filterGrid(''); // Reset grid to show all items
                
                // Remove focus to return to default state (no cursor)
                searchInput.blur();
                
                // Show animated text and restart animation
                const inputWrapper = document.querySelector('.search-bar__input-wrapper');
                if (inputWrapper) {
                    inputWrapper.classList.remove('hidden');
                }
                startAnimation();
            });
        }
        
        // Filter grid items based on search query
        function filterGrid(query) {
            const items = document.querySelectorAll('.item');
            
            if (!query || query.trim().length === 0) {
                // Show all items
                items.forEach(item => {
                    item.style.display = '';
                });
                return;
            }
            
            const searchTerm = query.toLowerCase().trim();
            
            // Helper function to check if search term appears as a whole word
            // Uses word boundaries (non-word characters or start/end of string)
            function matchesWholeWord(text, term) {
                if (!text || !term) return false;
                // Create regex pattern: word boundary before and after the term
                // \b is word boundary, but we need to handle special characters too
                // Use a pattern that matches: start of string OR non-word char, then term, then end of string OR non-word char
                const pattern = new RegExp(`(^|[^a-z0-9])${term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}([^a-z0-9]|$)`, 'i');
                return pattern.test(text);
            }
            
            items.forEach((item, index) => {
                if (index >= portfolioData.length) return;
                
                const itemData = portfolioData[index];
                const itemTags = (itemData.tags || []).map(t => t.toLowerCase()); // Keep as array of individual tags
                const projectName = (itemData.projectName || '').toLowerCase();
                const metadata = (itemData.metadata || '').toLowerCase();
                const filename = (itemData.filename || '').toLowerCase();
                const folder = (itemData.folder || '').toLowerCase();
                
                // Check if search term matches any individual tag (partial match allowed for tags)
                const tagMatches = itemTags.some(tag => tag.includes(searchTerm));
                
                // Check if search term matches filename, folder, metadata, or project name (whole word only)
                const filenameMatch = matchesWholeWord(filename, searchTerm);
                const folderMatch = matchesWholeWord(folder, searchTerm);
                const metadataMatch = matchesWholeWord(metadata, searchTerm);
                const projectNameMatch = matchesWholeWord(projectName, searchTerm);
                
                const otherFieldsMatch = filenameMatch || folderMatch || metadataMatch || projectNameMatch;
                
                const shouldShow = tagMatches || otherFieldsMatch;
                
                if (shouldShow) {
                    item.style.display = '';
                } else {
                    item.style.display = 'none';
                }
            });
        }
        
        // Dropdowns removed - back to original search bar

        // Disabled: Development guide keyboard shortcuts (G key, 0 key)
        // document.addEventListener('keydown', function(e) {
        //     if (e.key === 'g' || e.key === 'G') {
        //         const overlay = document.getElementById('grid-overlay');
        //         if (overlay) {
        //             const isHidden = overlay.classList.toggle('hidden');
        //             if (isHidden) {
        //                 // Hide section padding guides when grid is hidden
        //                 removeSectionPaddingGuides();
        //             } else {
        //                 // Show section padding guides when grid is shown
        //                 setTimeout(() => {
        //                     const sectionGuides = document.querySelector('.section-padding-guides');
        //                     if (!sectionGuides) {
        //                         const tempOverlay = document.getElementById('grid-overlay');
        //                         if (tempOverlay) {
        //                             addSectionPaddingGuides(tempOverlay);
        //                         }
        //                     }
        //                 }, 100);
        //             }
        //         }
        //     }
        //     
        //     // Section guide toggle functionality (0 key)
        //     if (e.key === '0') {
        //         toggleSectionGuides();
        //     }
            
            // Size slider toggle - DISABLED
            // if (e.key === 's' || e.key === 'S') {
            //     const slider = document.querySelector('.size-slider');
            //     slider.classList.toggle('visible');
            // }
            
            // Debug strokes feature disabled
            // if (e.key === 'o' || e.key === 'O') {
            //     const isHidden = document.body.classList.toggle('hide-debug-strokes');
            //     // Save state to localStorage
            //     localStorage.setItem('hideDebugStrokes', isHidden ? 'true' : 'false');
            // }
        // });
        
        // Debug strokes feature disabled
        // Load saved debug strokes preference on page load
        // if (localStorage.getItem('hideDebugStrokes') === 'true') {
        //     document.body.classList.add('hide-debug-strokes');
        // }

        // Grid zoom system - simple and clean
        function getColumnLimits() {
            const isMobile = window.matchMedia('(max-width: 768px)').matches;
            return {
                min: isMobile ? 3 : 10,
                max: isMobile ? 6 : 18,
                default: isMobile ? 5 : 18
            };
        }
        
        let limits = getColumnLimits();
        let currentColumns = limits.default;

        // Update grid columns - single function that does everything
        function updateGridColumns(columns) {
            // Refresh limits and clamp columns
            limits = getColumnLimits();
            columns = Math.max(limits.min, Math.min(limits.max, parseInt(columns)));
            
            if (columns === currentColumns) return;
            
            currentColumns = columns;
            
            // Update CSS variable (this is what makes CSS grid work)
            document.documentElement.style.setProperty('--grid-columns', columns);
            
            // Save preference
            localStorage.setItem('gridColumns', columns.toString());
            
            // Update UI elements
            const sizeSlider = document.getElementById('sizeSlider');
            const columnCount = document.getElementById('columnCount');
            const gridColumnCounter = document.getElementById('gridColumnCounter');
            
            if (sizeSlider) {
                sizeSlider.min = limits.min;
                sizeSlider.max = limits.max;
                sizeSlider.value = columns;
            }
            if (columnCount) columnCount.textContent = columns;
            if (gridColumnCounter) gridColumnCounter.textContent = columns;
            
            // Re-render gallery
            if (portfolioData && portfolioData.length > 0) {
                renderGallery(false);
                setupLazyLoading();
                setTimeout(() => updateGridGuide(columns), 10);
            }
        }

        // Update grid guide to match current column count - perfectly aligned with gallery
        function updateGridGuide(columns) {
            const gridOverlay = document.getElementById('grid-overlay');
            const gridColumnCounter = document.getElementById('gridColumnCounter');
            if (!gridOverlay) return;
            
            // Update column counter
            if (gridColumnCounter) {
                gridColumnCounter.textContent = columns;
            }
            
            // Remove all existing guides (but keep the counter)
            const counter = gridOverlay.querySelector('.grid-column-counter');
            gridOverlay.innerHTML = '';
            if (counter) {
                gridOverlay.appendChild(counter);
            }
            
            // Get gallery element to match its exact position
            const gallery = document.getElementById('grid');
            if (!gallery) return;
            
            // Wait for gallery to be rendered, then align guides
            setTimeout(() => {
                const galleryRect = gallery.getBoundingClientRect();
                
                // Position overlay to match gallery exactly
                gridOverlay.style.left = galleryRect.left + 'px';
                gridOverlay.style.width = galleryRect.width + 'px';
                
                // Create guides for current column count using exact CSS variables
                for (let i = 0; i < columns; i++) {
                    const guide = document.createElement('div');
                    guide.className = 'column-guide';
                    guide.style.left = `calc(${i} * (var(--column-width) + var(--grid-gap)))`;
                    guide.style.width = 'var(--column-width)';
                    gridOverlay.appendChild(guide);
                }
                
                // Add section padding indicators (only if grid is visible)
                if (!gridOverlay.classList.contains('hidden')) {
                    removeSectionPaddingGuides();
                    addSectionPaddingGuides(gridOverlay);
                }
            }, 0);
        }
        
        // Add section padding guides to show horizontal padding and section boundaries
        function addSectionPaddingGuides(gridOverlay) {
            // Remove any existing guides first
            removeSectionPaddingGuides();
            // Get body padding
            const bodyStyle = getComputedStyle(document.body);
            const bodyPadding = parseFloat(bodyStyle.paddingLeft) || 0;
            
        }
        
        // Remove section padding guides when grid is hidden
        function removeSectionPaddingGuides() {
            const guides = document.querySelectorAll('.section-padding-guides');
            guides.forEach(guide => guide.remove());
        }
        
        // Update section padding guides on scroll/resize
        let sectionGuidesUpdateRaf;
        function updateSectionPaddingGuides() {
            const gridOverlay = document.getElementById('grid-overlay');
            if (gridOverlay && !gridOverlay.classList.contains('hidden')) {
                if (sectionGuidesUpdateRaf) {
                    cancelAnimationFrame(sectionGuidesUpdateRaf);
                }
                sectionGuidesUpdateRaf = requestAnimationFrame(() => {
                    removeSectionPaddingGuides();
                    addSectionPaddingGuides(gridOverlay);
                });
            }
        }
        
        // Listen for scroll and resize to update section guides
        window.addEventListener('scroll', updateSectionPaddingGuides, { passive: true });
        window.addEventListener('resize', updateSectionPaddingGuides, { passive: true });

        // Section guides functionality (0 key)
        let sectionGuidesVisible = false;
        
        function toggleSectionGuides() {
            sectionGuidesVisible = !sectionGuidesVisible;
            if (sectionGuidesVisible) {
                addSectionGuides();
            } else {
                removeSectionGuides();
            }
        }
        
        function addSectionGuides() {
            // Remove any existing guides first
            removeSectionGuides();
            
            const sectionsContainer = document.createElement('div');
            sectionsContainer.className = 'section-guides-overlay';
            sectionsContainer.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                pointer-events: none;
                z-index: 99997;
            `;
            
            // Define sections to analyze
            const sections = [
                { selector: '#grid', name: 'Grid', color: 'rgba(255, 100, 100, 0.3)' },
                { selector: '.header', name: 'Header', color: 'rgba(100, 100, 255, 0.3)' },
                { selector: '.thumbnail-filmstrip', name: 'Thumbnail Filmstrip', color: 'rgba(255, 255, 100, 0.3)' },
                { selector: '.size-slider', name: 'Size Slider', color: 'rgba(255, 100, 255, 0.3)' },
                { selector: '.header-bar', name: 'Header Bar', color: 'rgba(100, 255, 255, 0.3)' }
            ];
            
            // Store label positions to prevent overlaps
            const labelPositions = [];
            const labelHeight = 200; // Approximate height for collision detection
            const labelWidth = 300;
            const spacing = 10; // Minimum spacing between labels
            
            // Helper function to check if two rectangles overlap
            function rectanglesOverlap(rect1, rect2) {
                return !(rect1.right + spacing < rect2.left || 
                        rect1.left > rect2.right + spacing ||
                        rect1.bottom + spacing < rect2.top || 
                        rect1.top > rect2.bottom + spacing);
            }
            
            // Helper function to find non-overlapping position
            function findNonOverlappingPosition(rect, labelWidth, labelHeight) {
                let x = rect.left + 10;
                let y = rect.top + 10;
                let attempts = 0;
                const maxAttempts = 50;
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                while (attempts < maxAttempts) {
                    // Ensure label stays within viewport
                    x = Math.max(10, Math.min(x, viewportWidth - labelWidth - 10));
                    y = Math.max(10, Math.min(y, viewportHeight - labelHeight - 10));
                    
                    const testRect = {
                        left: x,
                        top: y,
                        right: x + labelWidth,
                        bottom: y + labelHeight
                    };
                    
                    let overlaps = false;
                    for (const existingPos of labelPositions) {
                        if (rectanglesOverlap(testRect, existingPos)) {
                            overlaps = true;
                            break;
                        }
                    }
                    
                    if (!overlaps) {
                        return { x, y };
                    }
                    
                    // Try different positions: right, bottom, bottom-right, etc.
                    if (attempts % 4 === 0) {
                        x = Math.max(10, rect.right - labelWidth - 10); // Try right side
                        y = rect.top + 10;
                    } else if (attempts % 4 === 1) {
                        x = rect.left + 10; // Back to left
                        y = Math.max(10, rect.bottom - labelHeight - 10); // Try bottom
                    } else if (attempts % 4 === 2) {
                        x = Math.max(10, rect.right - labelWidth - 10); // Right side
                        y = Math.max(10, rect.bottom - labelHeight - 10); // Bottom
                    } else {
                        // Try offsetting vertically
                        y = rect.top + 10 + (attempts * 25);
                        x = rect.left + 10;
                    }
                    
                    attempts++;
                }
                
                // If we can't find a good position, offset it diagonally
                const offsetX = labelPositions.length * 25;
                const offsetY = labelPositions.length * 30;
                return { 
                    x: Math.max(10, Math.min(rect.left + 10 + offsetX, viewportWidth - labelWidth - 10)), 
                    y: Math.max(10, Math.min(rect.top + 10 + offsetY, viewportHeight - labelHeight - 10)) 
                };
            }
            
            sections.forEach(section => {
                const element = document.querySelector(section.selector);
                if (element) {
                    const rect = element.getBoundingClientRect();
                    const styles = getComputedStyle(element);
                    
                    // Get padding values
                    const paddingTop = parseFloat(styles.paddingTop) || 0;
                    const paddingRight = parseFloat(styles.paddingRight) || 0;
                    const paddingBottom = parseFloat(styles.paddingBottom) || 0;
                    const paddingLeft = parseFloat(styles.paddingLeft) || 0;
                    
                    // Get margin values
                    const marginTop = parseFloat(styles.marginTop) || 0;
                    const marginRight = parseFloat(styles.marginRight) || 0;
                    const marginBottom = parseFloat(styles.marginBottom) || 0;
                    const marginLeft = parseFloat(styles.marginLeft) || 0;
                    
                    // Get dimensions
                    const width = Math.round(rect.width);
                    const height = Math.round(rect.height);
                    
                    // Create section outline
                    const outline = document.createElement('div');
                    outline.className = 'section-guide-outline';
                    outline.style.cssText = `
                        position: fixed;
                        left: ${rect.left}px;
                        top: ${rect.top}px;
                        width: ${width}px;
                        height: ${height}px;
                        border: 3px solid ${section.color.replace('0.3', '1')};
                        background: ${section.color};
                        box-sizing: border-box;
                        pointer-events: none;
                    `;
                    sectionsContainer.appendChild(outline);
                    
                    // Find non-overlapping position for label
                    const labelPos = findNonOverlappingPosition(rect, labelWidth, labelHeight);
                    
                    // Store this label's position
                    labelPositions.push({
                        left: labelPos.x,
                        top: labelPos.y,
                        right: labelPos.x + labelWidth,
                        bottom: labelPos.y + labelHeight
                    });
                    
                    // Create info label
                    const label = document.createElement('div');
                    label.className = 'section-guide-label';
                    label.style.cssText = `
                        position: fixed;
                        left: ${labelPos.x}px;
                        top: ${labelPos.y}px;
                        background: rgba(0, 0, 0, 0.9);
                        color: white;
                        padding: 8px 12px;
                        font-family: monospace;
                        font-size: 11px;
                        line-height: 1.4;
                        border-radius: 4px;
                        pointer-events: none;
                        max-width: ${labelWidth}px;
                        z-index: 99998;
                    `;
                    
                    // Build stats text
                    let statsText = `<strong style="color: ${section.color.replace('0.3', '1')};">${section.name}</strong><br>`;
                    statsText += `Size: ${width} × ${height}px<br>`;
                    statsText += `Position: ${Math.round(rect.left)}, ${Math.round(rect.top)}px<br><br>`;
                    
                    if (paddingTop || paddingRight || paddingBottom || paddingLeft) {
                        statsText += `<strong>Padding:</strong><br>`;
                        statsText += `  Top: ${paddingTop}px<br>`;
                        statsText += `  Right: ${paddingRight}px<br>`;
                        statsText += `  Bottom: ${paddingBottom}px<br>`;
                        statsText += `  Left: ${paddingLeft}px<br><br>`;
                    }
                    
                    if (marginTop || marginRight || marginBottom || marginLeft) {
                        statsText += `<strong>Margin:</strong><br>`;
                        statsText += `  Top: ${marginTop}px<br>`;
                        statsText += `  Right: ${marginRight}px<br>`;
                        statsText += `  Bottom: ${marginBottom}px<br>`;
                        statsText += `  Left: ${marginLeft}px<br>`;
                    }
                    
                    label.innerHTML = statsText;
                    sectionsContainer.appendChild(label);
                    
                    // Add padding visualization lines
                    if (paddingTop > 0) {
                        const paddingLine = document.createElement('div');
                        paddingLine.style.cssText = `
                            position: fixed;
                            left: ${rect.left}px;
                            top: ${rect.top}px;
                            width: ${width}px;
                            height: ${paddingTop}px;
                            border-top: 2px dashed ${section.color.replace('0.3', '0.8')};
                            pointer-events: none;
                        `;
                        sectionsContainer.appendChild(paddingLine);
                    }
                    
                    if (paddingBottom > 0) {
                        const paddingLine = document.createElement('div');
                        paddingLine.style.cssText = `
                            position: fixed;
                            left: ${rect.left}px;
                            top: ${rect.bottom - paddingBottom}px;
                            width: ${width}px;
                            height: ${paddingBottom}px;
                            border-bottom: 2px dashed ${section.color.replace('0.3', '0.8')};
                            pointer-events: none;
                        `;
                        sectionsContainer.appendChild(paddingLine);
                    }
                    
                    if (paddingLeft > 0) {
                        const paddingLine = document.createElement('div');
                        paddingLine.style.cssText = `
                            position: fixed;
                            left: ${rect.left}px;
                            top: ${rect.top}px;
                            width: ${paddingLeft}px;
                            height: ${height}px;
                            border-left: 2px dashed ${section.color.replace('0.3', '0.8')};
                            pointer-events: none;
                        `;
                        sectionsContainer.appendChild(paddingLine);
                    }
                    
                    if (paddingRight > 0) {
                        const paddingLine = document.createElement('div');
                        paddingLine.style.cssText = `
                            position: fixed;
                            left: ${rect.right - paddingRight}px;
                            top: ${rect.top}px;
                            width: ${paddingRight}px;
                            height: ${height}px;
                            border-right: 2px dashed ${section.color.replace('0.3', '0.8')};
                            pointer-events: none;
                        `;
                        sectionsContainer.appendChild(paddingLine);
                    }
                }
            });
            
            document.body.appendChild(sectionsContainer);
            
            // Update on scroll/resize
            window.addEventListener('scroll', updateSectionGuides, { passive: true });
            window.addEventListener('resize', updateSectionGuides, { passive: true });
        }
        
        function removeSectionGuides() {
            const guides = document.querySelectorAll('.section-guides-overlay');
            guides.forEach(guide => guide.remove());
        }
        
        let sectionGuidesUpdateRafId;
        function updateSectionGuides() {
            if (sectionGuidesVisible) {
                if (sectionGuidesUpdateRafId) {
                    cancelAnimationFrame(sectionGuidesUpdateRafId);
                }
                sectionGuidesUpdateRafId = requestAnimationFrame(() => {
                    removeSectionGuides();
                    addSectionGuides();
                });
            }
        }

        // Update navigation button handlers based on mode
        function updateNavButtonHandlers() {
            const headerBars = document.querySelectorAll('.header-bar');
            const isLightboxMode = headerBars[0]?.classList.contains('header-bar--lightbox-mode');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            const zoomInBtn = document.getElementById('zoomInBtn');
            
            if (zoomOutBtn) {
                zoomOutBtn.onclick = isLightboxMode 
                    ? () => navigate(-1)
                    : () => {
                        limits = getColumnLimits();
                        if (currentColumns < limits.max) {
                            updateGridColumns(currentColumns + 1);
                        }
                    };
            }
            
            if (zoomInBtn) {
                zoomInBtn.onclick = isLightboxMode
                    ? () => navigate(1)
                    : () => {
                        limits = getColumnLimits();
                        if (currentColumns > limits.min) {
                            updateGridColumns(currentColumns - 1);
                        }
                    };
            }
        }

        // Size slider functionality (syncs with zoom buttons)
        const sizeSlider = document.getElementById('sizeSlider');
        if (sizeSlider) {
            // Update slider range on resize
        function updateSliderRange() {
            limits = getColumnLimits();
                sizeSlider.min = limits.min;
                sizeSlider.max = limits.max;
                
                // Clamp current columns to new range if needed
                if (currentColumns > limits.max) {
                    updateGridColumns(limits.max);
                } else if (currentColumns < limits.min) {
                    updateGridColumns(limits.min);
                } else {
                sizeSlider.value = currentColumns;
            }
        }
        
        window.addEventListener('resize', updateSliderRange);
            
            sizeSlider.addEventListener('input', function() {
                updateGridColumns(parseInt(this.value));
            });
            
            // Set initial range
            updateSliderRange();
        }
        
        // Initialize grid guide on load
        updateGridGuide(currentColumns);
        
        // Initialize nav button handlers
        updateNavButtonHandlers();

        // Add unique colored strokes to all divs that don't already have borders
        // DISABLED - commented out for now
        /*
        (function() {
            let globalColorIndex = 0;
            
            // Generate a unique color for each div
            function generateUniqueColor(index) {
                // Use HSL color space for better color distribution
                const hue = (index * 137.508) % 360; // Golden angle for good distribution
                const saturation = 70 + (index % 30); // Vary saturation between 70-100
                const lightness = 40 + (index % 30); // Vary lightness between 40-70
                return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            }
            
            function hasExistingBorder(div) {
                const computedStyle = window.getComputedStyle(div);
                const borderWidth = computedStyle.borderWidth;
                const borderStyle = computedStyle.borderStyle;
                
                // Parse border width - could be "1px 1px 1px 1px" or "1px"
                const widths = borderWidth.split(/\s+/).map(w => parseFloat(w));
                const hasVisibleBorder = widths.some(w => w > 0) && 
                                        borderStyle && 
                                        borderStyle !== 'none';
                
                // Also check inline style for border
                const inlineBorder = div.style.border || div.style.borderWidth || div.style.borderStyle;
                if (inlineBorder && inlineBorder !== 'none' && !inlineBorder.includes('0px')) {
                    return true;
                }
                
                return hasVisibleBorder;
            }
            
            function addUniqueColoredStrokes() {
                const allDivs = document.querySelectorAll('div:not([data-debug-stroke])');
                let processedCount = 0;
                
                allDivs.forEach(div => {
                    // Skip if already has a border (excluding our debug border)
                    if (hasExistingBorder(div)) {
                        div.setAttribute('data-debug-skip', 'true');
                        return;
                    }
                    
                    // Add unique colored border
                    const uniqueColor = generateUniqueColor(globalColorIndex);
                    div.style.border = `1px solid ${uniqueColor}`;
                    div.setAttribute('data-debug-stroke', 'true');
                    globalColorIndex++;
                    processedCount++;
                });
                
                if (processedCount > 0) {
                    console.log(`Applied unique colored strokes to ${processedCount} new divs (total: ${globalColorIndex})`);
                }
            }
            
            // Run after DOM is fully loaded
            function initDebugStrokes() {
                setTimeout(addUniqueColoredStrokes, 500);
                
                // Watch for dynamically added divs
                const observer = new MutationObserver((mutations) => {
                    let hasNewDivs = false;
                    mutations.forEach((mutation) => {
                        mutation.addedNodes.forEach((node) => {
                            if (node.nodeType === 1 && (node.tagName === 'DIV' || node.querySelectorAll)) {
                                hasNewDivs = true;
                            }
                        });
                    });
                    if (hasNewDivs) {
                        setTimeout(addUniqueColoredStrokes, 100);
                    }
                });
                
                observer.observe(document.body, {
                    childList: true,
                    subtree: true
                });
            }
            
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initDebugStrokes);
            } else {
                initDebugStrokes();
            }
        })();
        */

        /*
        // Screensaver functionality - DISABLED
        (function() {
            let mouseTimer = null;
            let screensaverActive = false;
            let screensaverInterval = null;
            let currentIndex = 0;
            let shuffledItems = [];
            const SCREENSAVER_DELAY = 4000; // 4 seconds
            const ITEM_DISPLAY_TIME = 2000; // 2 seconds per item
            
            // Create screensaver overlay
            const screensaver = document.createElement('div');
            screensaver.id = 'screensaver';
            screensaver.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: #000;
                z-index: 99999;
                display: none;
                align-items: center;
                justify-content: center;
                overflow: hidden;
            `;
            
            const screensaverMedia = document.createElement('div');
            screensaverMedia.style.cssText = `
                width: 100%;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            screensaver.appendChild(screensaverMedia);
            document.body.appendChild(screensaver);
            
            // Reset mouse timer
            function resetMouseTimer() {
                if (mouseTimer) {
                    clearTimeout(mouseTimer);
                }
                
                if (screensaverActive) {
                    hideScreensaver();
                }
                
                mouseTimer = setTimeout(() => {
                    showScreensaver();
                }, SCREENSAVER_DELAY);
            }
            
            // Show screensaver
            function showScreensaver() {
                if (screensaverActive || !portfolioData || portfolioData.length === 0) return;
                
                screensaverActive = true;
                
                // Shuffle portfolio items randomly
                shuffledItems = [...portfolioData].sort(() => Math.random() - 0.5);
                currentIndex = 0;
                
                screensaver.style.display = 'flex';
                displayNextItem();
                
                // Cycle through items
                screensaverInterval = setInterval(() => {
                    displayNextItem();
                }, ITEM_DISPLAY_TIME);
            }
            
            // Hide screensaver
            function hideScreensaver() {
                screensaverActive = false;
                screensaver.style.display = 'none';
                
                if (screensaverInterval) {
                    clearInterval(screensaverInterval);
                    screensaverInterval = null;
                }
                
                // Clear media
                screensaverMedia.innerHTML = '';
            }
            
            // Display next item
            function displayNextItem() {
                if (shuffledItems.length === 0) return;
                
                const item = shuffledItems[currentIndex % shuffledItems.length];
                currentIndex++;
                
                screensaverMedia.innerHTML = '';
                
                const mediaUrl = item.url || item.thumbnailUrl;
                if (!mediaUrl) return;
                
                let mediaElement;
                
                if (item.type === 'video') {
                    mediaElement = document.createElement('video');
                    mediaElement.src = mediaUrl;
                    mediaElement.muted = true;
                    mediaElement.autoplay = true;
                    mediaElement.loop = true;
                    mediaElement.playsInline = true;
                    mediaElement.style.cssText = `
                        max-width: 100%;
                        max-height: 100%;
                        width: auto;
                        height: auto;
                        object-fit: contain;
                    `;
                } else {
                    mediaElement = document.createElement('img');
                    mediaElement.src = mediaUrl;
                    mediaElement.style.cssText = `
                        max-width: 100%;
                        max-height: 100%;
                        width: auto;
                        height: auto;
                        object-fit: contain;
                    `;
                }
                
                screensaverMedia.appendChild(mediaElement);
            }
            
            // Track mouse movement
            let lastMouseMove = Date.now();
            document.addEventListener('mousemove', () => {
                lastMouseMove = Date.now();
                resetMouseTimer();
            });
            
            // Track touch events (for mobile)
            document.addEventListener('touchstart', () => {
                lastMouseMove = Date.now();
                resetMouseTimer();
            });
            
            // Initialize on page load
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    resetMouseTimer();
                });
            } else {
                resetMouseTimer();
            }
        })();
        */

    </script>
    
    <!-- GSAP for smooth scrolling -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollToPlugin.min.js"></script>
    
    <script>
        // Initialize GSAP for fluid scroll movement
        gsap.registerPlugin(ScrollTrigger, ScrollToPlugin);
        
        // Wait for DOM to be ready
        document.addEventListener('DOMContentLoaded', function() {
            // Smooth scroll using GSAP - lightweight approach
            let currentScroll = window.pageYOffset;
            let targetScroll = currentScroll;
            let isScrolling = false;
            let scrollTween = null;
            
            // Check if cover is visible
            function isCoverVisible() {
                const brandSvgsStatic = document.getElementById('brandSvgsStatic');
                return document.body && 
                       document.body.classList.contains('brand-logo-visible') && 
                       brandSvgsStatic && 
                       !brandSvgsStatic.classList.contains('dismissed');
            }
            
            // Stop all GSAP scrolling when cover is visible
            function stopGSAPScrolling() {
                if (scrollTween) {
                    scrollTween.kill();
                    scrollTween = null;
                }
                isScrolling = false;
            }
            
            // Smooth scroll update function
            function smoothScroll() {
                // Don't scroll if cover is visible
                if (isCoverVisible()) {
                    stopGSAPScrolling();
                    return;
                }
                
                if (Math.abs(targetScroll - currentScroll) > 0.1) {
                    currentScroll += (targetScroll - currentScroll) * 0.15; // Smoothing factor
                    window.scrollTo(0, currentScroll);
                    requestAnimationFrame(smoothScroll);
                } else {
                    currentScroll = targetScroll;
                    window.scrollTo(0, currentScroll);
                    isScrolling = false;
                }
            }
            
            // Handle wheel events for smooth scrolling
            let wheelTimeout;
            window.addEventListener('wheel', function(e) {
                // Don't process wheel events if cover is visible
                if (isCoverVisible()) {
                    stopGSAPScrolling();
                    return;
                }
                
                // Cancel any existing scroll tween
                if (scrollTween) {
                    scrollTween.kill();
                }
                
                // Update target scroll position
                targetScroll += e.deltaY;
                targetScroll = Math.max(0, Math.min(targetScroll, document.documentElement.scrollHeight - window.innerHeight));
                
                // Start smooth scrolling if not already
                if (!isScrolling) {
                    isScrolling = true;
                    smoothScroll();
                }
                
                // Debounce: smooth to final position after scrolling stops
                clearTimeout(wheelTimeout);
                wheelTimeout = setTimeout(() => {
                    // Check again before starting tween
                    if (isCoverVisible()) {
                        stopGSAPScrolling();
                        return;
                    }
                    
                    if (scrollTween) scrollTween.kill();
                    
                    scrollTween = gsap.to({ value: currentScroll }, {
                        value: targetScroll,
                        duration: 0.6,
                        ease: "power2.out",
                        onUpdate: function() {
                            // Check if cover became visible during animation
                            if (isCoverVisible()) {
                                this.kill();
                                stopGSAPScrolling();
                                return;
                            }
                            currentScroll = this.targets()[0].value;
                            window.scrollTo(0, currentScroll);
                        },
                        onComplete: () => {
                            isScrolling = false;
                            scrollTween = null;
                        }
                    });
                }, 100);
            }, { passive: true });
            
            // Sync on programmatic scrolls
            window.addEventListener('scroll', function() {
                // Don't sync if cover is visible
                if (isCoverVisible()) {
                    stopGSAPScrolling();
                    return;
                }
                
                if (!isScrolling) {
                    currentScroll = window.pageYOffset;
                    targetScroll = currentScroll;
                }
            });
            
            // Watch for cover visibility changes and stop scrolling
            const brandSvgsStatic = document.getElementById('brandSvgsStatic');
            if (brandSvgsStatic) {
                const observer = new MutationObserver(() => {
                    if (isCoverVisible()) {
                        stopGSAPScrolling();
                    }
                });
                observer.observe(brandSvgsStatic, { attributes: true, attributeFilter: ['class'] });
                observer.observe(document.body, { attributes: true, attributeFilter: ['class'] });
            }
        });
    </script>
    
</body>
</html>

